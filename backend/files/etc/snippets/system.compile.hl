

/*
 * Compiles a snippet of C# code and saves it to /etc/foo.dll
 * as a library, for then to dynamically load it as a plugin.
 *
 * This particular code creates a slot, but you can create any
 * code you wish, and it doesn't have to be Hyperlambda related.
 *
 * Notice, to recompile the code, and/or unload the assembly we're
 * creating here, you'll need to invoke:
 *
 * system.unload-plugin:/etc/foo
 *
 * ... to unload the assembly before you reload it.
 */
system.compile
   references
      .:netstandard
      .:System.Runtime
      .:System.Private.CoreLib
      .:magic.node
      .:magic.signals.contracts
   code:@"

// Example C# code creating a Hyperlambda slot.
using System;
using magic.node;
using magic.signals.contracts;

// Our slot class.
[Slot(Name = ""foo"")]
public class Foo : ISlot
{
   public void Signal(ISignaler signaler, Node input)
   {
      input.Value = ""Foo was here!"";
   }
}"
   assembly-name:foo

// Saving our compiled CLR assembly to '/etc/foo.dll'.
io.file.save.binary:/etc/foo.dll
   get-value:x:@system.compile

// Loading assembly now that we've created it and saved it.
system.load-plugin:/etc/foo

/*
 * Compiles a snippet of C# code and saves it to /etc/foo.dll
 * as a library, for then to dynamically load it as a plugin.
 *
 * This particular code creates a slot, but you can create any
 * code you wish, and it doesn't have to be Hyperlambda related.
 */
system.compile
   references
      .:netstandard
      .:System.Runtime
      .:System.Private.CoreLib
      .:magic.node
      .:magic.signals.contracts
   code:@"

// Example C# code creating a Hyperlambda slot.
using System;
using magic.node;
using magic.signals.contracts;

// Our slot class.
[Slot(Name = ""foo"")]
public class Foo : ISlot
{
   public void Signal(ISignaler signaler, Node input)
   {
      input.Value = ""Foo was here!!"";
   }
}"
   assembly-name:foo

// Saving our compiled CLR assembly to '/etc/foo.dll'.
io.file.save.binary:/etc/foo.dll
   get-value:x:@system.compile

// Loading assembly now that we've created it and saved it.
system.load-plugin:/etc/foo.dll

// Executing [foo] slot now dynamically injected into AppDomain.
foo

// Unloading plugin.
system.unload-plugin:/etc/foo.dll

// Deleting foo.dll to make sure we clean up after ourselves.
io.file.delete:/etc/foo.dll

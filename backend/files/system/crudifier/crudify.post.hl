
// Creates an HTTP REST CRUD endpoint, wrapping your database and table according to the specified arguments.
.arguments
   verbose:bool
   join:bool
   databaseType:string
   moduleName:string
   database:string
   table:string
   moduleUrl:string
   returnId:bool
   template:string
   verb:string
   auth:string
   captcha:decimal
   log:string
   overwrite:bool
   validators:string
   cache:int
   publicCache:bool
   cqrs:bool
   cqrsAuthorisation:string
   cqrsAuthorisationValues:string
   args:*
   conditions:*
   paging:bool
   sorting:bool
   aggregate:bool
   distinct:bool
   search:bool
.description:Creates an HTTP REST CRUD endpoint, wrapping your database and table according to the specified arguments
.type:internal

// Sanity checks invocation.
validators.mandatory:x:@.arguments/*/moduleName
validators.mandatory:x:@.arguments/*/database
validators.mandatory:x:@.arguments/*/table
validators.mandatory:x:@.arguments/*/moduleUrl
validators.mandatory:x:@.arguments/*/template
validators.mandatory:x:@.arguments/*/verb
validators.enum:x:@.arguments/*/databaseType
   .:mysql
   .:pgsql
   .:mssql
   .:sqlite
validators.enum:x:@.arguments/*/verb
   .:post
   .:get
   .:put
   .:delete
validators.enum:x:@.arguments/*/template
   .:/system/crudifier/templates/crud.template.post.hl
   .:/system/crudifier/templates/crud.template.get.hl
   .:/system/crudifier/templates/crud.template.put.hl
   .:/system/crudifier/templates/crud.template.delete.hl
   .:/system/crudifier/templates/crud.template-no-operator.get.hl
validators.enum:x:@.arguments/*/cqrsAuthorisation
   .:inherited
   .:roles
   .:groups
   .:users
   .:none

// Defaulting [databaseType] to default database type from config.
if
   not
      exists:x:@.arguments/*/databaseType
   .lambda

      // Just inserting value from config into [.arguments] for simplicity.
      config.get:"magic:databases:default"
      unwrap:x:+/*/*
      add:x:@.arguments
         .
            databaseType:x:@config.get

// Ensures user is authorized to access endpoint.
auth.ticket.verify:root

// Synchronising access to endpoint to avoid race condition.
semaphore:crudifier

   // Ensures user is authorized to access endpoint.
   auth.ticket.verify:root

   // Temporary list of all columns in database.
   .temp-cols

   // Sanity checking module name, to prevent overwriting "/system/".
   strings.to-lower:x:@.arguments/*/moduleName
   if
      eq
         get-value:x:@strings.to-lower
         .:system
      .lambda
         throw:"You can't use the name 'system' as your module's name"
            public:true
            status:401

   // Sanity checking module name, to make sure it has a name at all.
   if
      or
         eq
            get-value:x:@.arguments/*/moduleName
            .:
         eq
            get-value:x:@.arguments/*/moduleName
            .
      .lambda
         throw:"You can't use an empty string as your module's name. Your module must have a name."
            public:true
            status:401

   // Creating a log entry explaining roughly what we're about to do.
   log.info:Generating CRUD backend
      module:x:@.arguments/*/moduleName
      databaseType:x:@.arguments/*/databaseType
      database:x:@.arguments/*/database
      table:x:@.arguments/*/table
      verb:x:@.arguments/*/verb

   // Making sure we create a valid filename.
   .filename
   set-value:x:-
      strings.replace:x:@.arguments/*/moduleUrl
         .:.
         .:/

   /*
    * Creating our endpoint according to arguments given, by using [apply]
    * on the [template] file given.
    */
   io.file.load:x:@.arguments/*/template
   hyper2lambda:x:-
      comments:bool:true
   unwrap:x:+/*
   apply:x:@hyper2lambda
      database-type:x:@.arguments/*/databaseType
      database:x:@.arguments/*/database
      table:x:@.arguments/*/table
      return-id:x:@.arguments/*/returnId
      args

   /*
    * Then ensuring we create a log entry during invocation of endpoint,
    * if the caller wants us to do such a thing.
    */
   if
      and
         exists:x:@.arguments/*/log
         not
            eq
               get-value:x:@.arguments/*/log
               .:
         not
            eq
               get-value:x:@.arguments/*/log
               .
      .lambda
         unwrap:x:+/*/*/log.info
         insert-after:x:@apply/*/.type
            .
               ..:Logging invocation.
               auth.ticket.get
               lambda2hyper:x:@.arguments/*
               log.info:x:@.arguments/*/log
                  username:x:@auth.ticket.get
                  arguments:x:@lambda2hyper

   /*
    * Making sure we append validators, if given by client.
    * 
    * Notice, we only do this for PUT or POST verbs.
    */
   if
      and
         exists:x:@.arguments/*/validators
         not
            eq
               get-value:x:@.arguments/*/validators
               .:
         or
            eq
               get-value:x:@.arguments/*/verb
               .:post
            eq
               get-value:x:@.arguments/*/verb
               .:put
      .lambda
         insert-after:x:@apply/*/.type
            hyper2lambda:x:@.arguments/*/validators

   /*
    * Then ensuring we turn on authorization to our endpoint according
    * to caller's specifications, if caller supplied an [auth] value.
    */
   if
      exists:x:@.arguments/*/auth
      .lambda

         /*
          * Checking if '' was provided as the value for authentication,
          * at which point we simply add authentication, without any
          * roles - Ensuring only authenticated users can access endpoint,
          * but no requirements in regards to roles are specified.
          */
         if
            eq
               get-value:x:@.arguments/*/auth
               .:*
            .lambda

               // No roles specified, but user must be authenticated.
               insert-after:x:@apply/*/.type
                  .

                     ..:Verifying user is authorized to access endpoint.
                     auth.ticket.verify
         else

            // Comma separated list of roles specified.
            unwrap:x:+/*/*/auth.ticket.verify
            insert-after:x:@apply/*/.type
               .

                  ..:Verifying user is authorized to access endpoint.
                  auth.ticket.verify:x:@.arguments/*/auth

   /*
    * Then ensuring we turn reCAPTCHA if caller specified a [captcha] value.
    */
   if
      exists:x:@.arguments/*/captcha
      .lambda

         add:x:@apply/*/.arguments
            .
               recaptcha:string
         unwrap:x:+/**/min
         insert-after:x:@apply/*/.type
            .
               ..:Checking reCAPTCHA value if backend is configured with reCAPTCHA configuration settings.
               config.get:"magic:auth:recaptcha:key"
               config.get:"magic:auth:recaptcha:secret"
               if
                  and
                     neq:x:@config.get
                        .
                     neq:x:@config.get
                        .:
                     neq:x:@config.get/@config.get
                        .
                     neq:x:@config.get/@config.get
                        .:
                  .lambda

                     ..:reCAPTCHA configuration settings found.
                     validators.mandatory:x:@.arguments/*/recaptcha
                     validators.recaptcha:x:@.arguments/*/recaptcha/[0,1]
                        site-key:x:@config.get/@config.get
                        secret:x:@config.get
                        min:x:@.arguments/*/captcha

               ..:To remove reCAPTCHA value preventing it from being used as an argument further down in file.
               remove-nodes:x:@.arguments/*/recaptcha/[0,1]

   /*
    * Then making sure we do our specialized transformation,
    * according to verb requested by caller.
    */
   switch:x:@.arguments/*/verb

      // HTTP DELETE special case
      case:delete

         // Sanity checking invocation.
         if
            eq
               get-count:x:@.arguments/*/args/*/primary/*
               .:int:0
            .lambda

               // Cannot have a DELETE endpoint without primary keys.
               throw:There are no actual primary keys declared for your DELETE endpoint.
                  public:true
                  status:401

         /*
          * Applying DELETE arguments.
          * 
          * This basically ensures that all primary keys becomes mandatory arguments.
          */
         add:x:@apply/*/.arguments
            get-nodes:x:@.arguments/*/args/*/primary/*/*
         insert-before:x:@apply/*/.arguments/*
            .
               ..:Primary key of record to delete, mandatory argument
         for-each:x:@.arguments/*/args/*/primary/*/*

            // Checking if this is our first loop iteration.
            if
               get-value:x:@.first
               .lambda

                  // Inserting comment describing what we're doing.
                  insert-before:x:@apply/*/data.connect/-
                     .
                        ..:Sanity checking invocation, making sure primary key(s) are specified.

            .x:@.arguments/*/
            set-value:x:@.x
               strings.concat
                  get-value:x:@.x
                  get-name:x:@.dp/#
            set-x:x:+/*/*/validators.mandatory
               convert:x:@.x
                  type:x
            insert-before:x:@apply/*/data.connect/-
               .
                  validators.mandatory

         // Making sure we apply "locked" columns.
         for-each:x:@.arguments/*/args/*/columns/*/*/locked/.
            set-name:x:+/*/1
               get-value:x:@.dp/#/*/locked
            insert-before:x:@apply/*/data.connect/-
               .
                  ..:Making sure we retrieve lock value for column.
                  .
            .x
            set-value:x:@.x
               strings.concat
                  .:@
                  get-value:x:@.dp/#/*/locked
            convert:x:@.x
               type:x
            set-x:x:+/+/*/1
               get-value:x:@convert
            set-name:x:+/*/1
               strings.concat
                  get-value:x:@.dp/#/*/name
                  .:.eq
            add:x:@apply/*/data.connect/*/data.delete/*/where/*/and
               .
                  ..:Table is locked on the following field.
                  .

      // HTTP GET special case
      case:get

         // Sanity checking invocation.
         if
            eq
               get-count:x:@.arguments/*/args/*/columns/*
               .:int:0
            .lambda

               // Cannot have a GET endpoint returning no actual columns.
               throw:There are no actual columns declared for your GET endpoint.
                  public:true
                  status:401

         // Checking if we have an [.arguments]/[args]/[cache] value.
         if
            and
               exists:x:@.arguments/*/cache
               not
                  eq
                     get-value:x:@.arguments/*/cache
                     .:
               not
                  eq
                     get-value:x:@.arguments/*/cache
                     .:0
            .lambda

               /*
                * Caller wants results of endpoint to be cached, figuring out
                * if we should publicly or privately cache the result.
                */
               .scope:private
               if
                  eq
                     get-value:x:@.arguments/*/publicCache
                     .:bool:true
                  .lambda
                     set-value:x:@.scope
                        .:public
               strings.concat
                  get-value:x:@.scope
                  .:, max-age=
                  get-value:x:@.arguments/*/cache
               unwrap:x:+/*/*/*
               insert-after:x:@apply/*/.type
                  .
                     ..:Adding Cache-Control HTTP header.
                     response.headers.set
                        Cache-Control:x:@strings.concat

         /*
          * Checking if caller supplied an explicit conditions collection,
          * and if not, applying the default logic - If caller supplied an
          * explicit condition collection, we use that instead.
          */
         if
            exists:x:@.arguments/*/conditions
            .lambda

               // Applying custom conditions to endpoint.
               add:x:@apply/*/.arguments
                  get-nodes:x:@.arguments/*/conditions/*/*
         else

            /*
             * Creating and applying default conditions to endpoint
             * 
             * This is the part where we create our condition arguments, allowing
             * for filtering result when endpoint is invoked.
             * 
             * Making sure we legalize all the most common operators for all
             * columns, in addition to "like" conditions for string types of
             * endpoints.
             */
            .operators
               mt
               lt
               mteq
               lteq
               neq
               eq

            // Checking if caller wants 'verbose' scaffolding.
            if
               or
                  not
                     exists:x:@.arguments/*/verbose
                  not
                     get-value:x:@.arguments/*/verbose
               .lambda
                  remove-nodes:x:@.operators/*/mt
                  remove-nodes:x:@.operators/*/lt
                  remove-nodes:x:@.operators/*/mteq
                  remove-nodes:x:@.operators/*/lteq
                  remove-nodes:x:@.operators/*/neq

            // Applying arguments to endpoint.
            for-each:x:@.arguments/*/args/*/columns/*

               if
                  not-exists:x:@.dp/#/*/locked
                  .lambda

                     /*
                      * Checking if argument needs a ".like" comparison type,
                      * which is true only for "string" type of arguments.
                      */
                     if
                        eq
                           get-value:x:@.dp/#/*/type
                           .:string
                        .lambda

                           // String type of argument, appending ".like" to legal arguments.
                           .buffer
                              .name:x:@.dp/#/*/type
                           unwrap:x:@.buffer/*
                           set-name:x:@.buffer/*/.name
                              strings.concat
                                 get-value:x:@.arguments/*/table
                                 .:.
                                 get-value:x:@.dp/#/*/name
                                 .:.like
                           add:x:@apply/*/.arguments
                              get-nodes:x:@.buffer/*

                     /*
                      * Checking if argument is boolean type of argument, at which
                      * point we ONLY add ".eq" type of argument to it.
                      */
                     if
                        eq
                           get-value:x:@.dp/#/*/type
                           .:bool
                        .lambda

                           // Boolean type of argument, removing everything but ".eq" type of arguments.
                           .buffer
                              .name:x:@.dp/#/*/type
                           unwrap:x:@.buffer/*
                           set-name:x:@.buffer/*/.name
                              strings.concat
                                 get-value:x:@.arguments/*/table
                                 .:.
                                 get-value:x:@.dp/#/*/name
                                 .:.eq
                           add:x:@apply/*/.arguments
                              get-nodes:x:@.buffer/*
                     else

                        /*
                         * Not a boolean type of argument, hence looping through all of
                         * our default comparison operators.
                         */
                        for-each:x:@.operators/*
                           .buffer
                              .name:x:@.dp/@.dp/#/*/type
                           unwrap:x:@.buffer/*/.name
                           set-name:x:@.buffer/*/.name
                              strings.concat
                                 get-value:x:@.arguments/*/table
                                 .:.
                                 get-value:x:@.dp/@.dp/#/*/name
                                 .:.
                                 get-name:x:@.dp/#
                           add:x:@apply/*/.arguments
                              get-nodes:x:@.buffer/*
               strings.concat
                  get-value:x:@.arguments/*/table
                  .:.
                  get-value:x:@.dp/#/*/name
               unwrap:x:+/*/*
               add:x:@.temp-cols
                  .
                     .:x:@strings.concat

         /*
          * Making sure we explicitly declare which [columns] that our
          * endpoint should return, according to caller's specifications.
          */
         for-each:x:@.arguments/*/args/*/columns/*/*/name
            if
               not-exists:x:@.dp/#/./*/locked
               .lambda
                  set-name:x:+/*/*
                     strings.concat
                        get-value:x:@.arguments/*/table
                        .:.
                        get-value:x:@.dp/#
                  add:x:@apply/**/columns
                     .
                        .

         /*
          * Checking if caller wants to apply server side joins, at which point we left join
          * with all referenced tables referenced as foreign keys.
          */
         if
            eq
               get-value:x:@.arguments/*/join
               .:bool:true
            .lambda

               // Looping through all foreign keys making sure we left join with the referenced table.
               for-each:x:@.arguments/*/args/*/columns/*

                  /*
                   * Checking if currently iterated column has a [foreign_key] declaration,
                   * and that the foreign key column in the source table is not of type string.
                   */
                  if
                     and
                        exists:x:@.dp/#/*/foreign_key
                        not
                           eq
                              get-value:x:@.dp/#/*/type
                              .:string
                     .lambda

                        /*
                         * Currently iterated column has a [foreign_key] declaration.
                         * 
                         * First we need to create our [join] part.
                         */
                        .src-field
                        .dest-field
                        set-value:x:@.src-field
                           strings.concat
                              get-value:x:@.arguments/*/table
                              .:.
                              get-value:x:@.dp/#/*/name
                        set-value:x:@.dest-field
                           strings.concat
                              get-value:x:@.dp/#/*/name
                              .:.
                              get-value:x:@.dp/#/*/foreign_key/*/column
                        set-value:x:./*/add/*/*/*/*/*
                           get-value:x:@.dest-field
                        set-name:x:./*/add/*/*/*/*/*
                           get-value:x:@.src-field
                        unwrap:x:+/+/*/*/join/*/as
                        unwrap:x:+/*/*/join
                        add:x:@apply/**/table
                           .
                              join:x:@.dp/#/*/foreign_key/*/table
                                 as:x:@.dp/#/*/name
                                 type:left
                                 on
                                    and
                                       .

                        // Then we need to add the joined display [name] as a part of our result set.
                        .display-col
                        .display-name
                        set-value:x:@.display-col
                           strings.concat
                              get-value:x:@.dp/#/*/name
                              .:.
                              get-value:x:@.dp/#/*/foreign_key/*/name
                        set-value:x:@.display-name
                           strings.concat
                              get-value:x:@.dp/#/*/name
                              .:.
                              get-value:x:@.dp/#/*/foreign_key/*/name
                        unwrap:x:+/+/*/*/*
                        set-name:x:+/*/*
                           get-value:x:@.display-col
                        add:x:@apply/**/columns
                           .
                              .
                                 as:x:@.display-name

                        // Then we need to add the eq and like query parameters for the referenced columns.
                        set-name:x:+/+/*/*/like
                           strings.concat
                              get-value:x:@.display-col
                              .:.like
                        set-name:x:+/*/*/eq
                           strings.concat
                              get-value:x:@.display-col
                              .:.eq
                        add:x:@apply/*/.arguments
                           .
                              eq:string
                              like:string
                        unwrap:x:+/*/*
                        add:x:@.temp-cols
                           .
                              .:x:@.display-name

         // Checking if paging is turned off.
         if
            and
               exists:x:@.arguments/*/paging
               eq:x:@.arguments/*/paging
                  .:bool:false
            .lambda
               remove-nodes:x:@apply/*/.arguments/*/limit
               remove-nodes:x:@apply/*/.arguments/*/offset

         else

            insert-after:x:@apply/*/data.connect/0
               .
                  ..:Parametrising our read invocation with paging arguments if specified.
                  add:x:./*/data.read
                     get-nodes:x:@.arguments/*/limit
                     get-nodes:x:@.arguments/*/offset
                  remove-nodes:x:@.arguments/*/limit
                  remove-nodes:x:@.arguments/*/offset

         // Checking if sorting is turned off.
         if
            and
               exists:x:@.arguments/*/sorting
               eq:x:@.arguments/*/sorting
                  .:bool:false
            .lambda
               remove-nodes:x:@apply/*/.arguments/*/order
               remove-nodes:x:@apply/*/.arguments/*/direction

         else

            insert-after:x:@apply/*/data.connect/0
               .
                  ..:Parametrising our read invocation with ordering arguments if specified.
                  add:x:./*/data.read
                     get-nodes:x:@.arguments/*/order
                     get-nodes:x:@.arguments/*/direction
                  remove-nodes:x:@.arguments/*/order
                  remove-nodes:x:@.arguments/*/direction

         // Removing [operator] argument if there are "locked" columns.
         if:x:@.arguments/*/args/*/columns/*/*/locked
            remove-nodes:x:@apply/*/.arguments/*/operator
            remove-nodes:x:@apply/*/validators.enum/-
            remove-nodes:x:@apply/*/validators.enum
            remove-nodes:x:@apply/*/if/-
            remove-nodes:x:@apply/*/if
            remove-nodes:x:@apply/*/data.connect/*/remove-nodes/[0,1]

         // Making sure we apply "locked" columns.
         for-each:x:@.arguments/*/args/*/columns/*/*/locked/.
            set-name:x:+/*/1
               get-value:x:@.dp/#/*/locked
            insert-before:x:@apply/*/data.connect/-
               .
                  ..:Making sure we retrieve lock value for column.
                  .
            .x
            set-value:x:@.x
               strings.concat
                  .:@
                  get-value:x:@.dp/#/*/locked
            convert:x:@.x
               type:x
            set-x:x:+/+/*/1
               get-value:x:@convert
            set-name:x:+/*/1
               strings.concat
                  get-value:x:@.dp/#/*/name
                  .:.eq
            add:x:@apply/*/data.connect/*/data.read/*/where/*/and
               .
                  ..:Table is locked on the following field.
                  .

      // HTTP POST special cases
      case:post

         // Sanity checking invocation.
         if
            eq
               get-count:x:@.arguments/*/args/*/columns/*
               .:int:0
            .lambda

               // Cannot have a POST endpoint without any actual data to POST.
               throw:There are no actual columns declared for your POST endpoint.
                  public:true
                  status:401

         /*
          * Applying POST arguments, which are basically the [values] that
          * invokers of endpoint are allowed to insert during creationg of
          * record.
          */
         for-each:x:@.arguments/*/args/*/columns/*

            if
               not-exists:x:@.dp/#/*/locked
               .lambda
                  set-value:x:+/+/+/*/0
                     strings.concat
                        get-value:x:@.dp/#/*/name
                        .:" column value"
                  set-name:x:+/+/*/1
                     get-value:x:@.dp/#/*/name
                  set-value:x:+/*/1
                     get-value:x:@.dp/#/*/type
                  add:x:@apply/*/.arguments
                     .
                        ..
                        .

         /*
          * Checking if caller specified he wanted to have ID of item returned,
          * and if not, only returning success.
          */
         if
            not
               get-value:x:@.arguments/*/returnId
            .lambda
               remove-nodes:x:@apply/**/return/*
               add:x:@apply/**/return
                  .
                     result:success

         // Making sure we apply "locked" columns.
         for-each:x:@.arguments/*/args/*/columns/*/*/locked/.
            set-name:x:+/*/1
               get-value:x:@.dp/#/*/locked
            insert-before:x:@apply/*/data.connect/-
               .
                  ..:Making sure we retrieve lock value for column.
                  .
            .x
            set-value:x:@.x
               strings.concat
                  .:@
                  get-value:x:@.dp/#/*/locked
            convert:x:@.x
               type:x
            set-x:x:+/+/*/1
               get-value:x:@convert
            set-name:x:+/*/1
               get-value:x:@.dp/#/*/name
            add:x:@apply/*/data.connect/*/data.create/*/values
               .
                  ..:Table is locked on the following field.
                  .

      // HTTP PUT special cases
      case:put

         // Sanity checking invocation.
         if
            or
               eq
                  get-count:x:@.arguments/*/args/*/primary/*
                  .:int:0
               eq
                  get-count:x:@.arguments/*/args/*/columns/*
                  .:int:0
            .lambda

               /*
                * Cannot have a PUT endpoint without any [values] to modify and
                * [where] statements to declare which records to modify.
                */
               throw:There are no actual columns, and/or primary keys declared for your PUT endpoint.
                  public:true
                  status:401

         /*
          * Applying PUT arguments.
          * First our primary keys, which ends up becoming a [where] condition,
          * to avoid allowing for updating all records.
          * 
          * This is done by making sure all specified primary keys becomes mandatory
          * arguments when invoking the endpoint.
          */
         for-each:x:@.arguments/*/args/*/primary/*

            set-value:x:+/+/+/*/0
               strings.concat
                  get-value:x:@.dp/#/*/name
                  .:" column value being primary key of record to update, mandatory argument"
            set-name:x:+/+/*/1
               get-value:x:@.dp/#/*/name
            set-value:x:+/*/1
               get-value:x:@.dp/#/*/type
            add:x:@apply/*/.arguments
               .
                  ..
                  .
         .first:bool:true
         for-each:x:@.arguments/*/args/*/primary/*
            if
               get-value:x:@.first
               .lambda
                  set-value:x:@.first
                     .:bool:false
                  insert-after:x:@apply/*/.type
                     .
                        ..:Sanity checking invocation, making sure primary key(s) are specified.

            .x:@.arguments/*/
            set-value:x:@.x
               strings.concat
                  get-value:x:@.x
                  get-value:x:@.dp/#/*/name
            set-x:x:+/*/*
               convert:x:@.x
                  type:x
            insert-after:x:@apply/*/.type/+
               .
                  validators.mandatory

         /*
          * Then adding the [add] into [values] and [where] invocations to our endpoint.
          * This is done by a little bit of intelligent offsetting using expressions,
          * which we can get away with, since we know that all primary keys are mandatory,
          * and declared first in our [.arguments] node in our endpoint.
          */
         for-each:x:@.arguments/*/args/*/columns/*

            if
               not-exists:x:@.dp/#/*/locked
               .lambda
                  set-value:x:+/+/+/*/0
                     strings.concat
                        get-value:x:@.dp/#/*/name
                        .:" column's new value"
                  set-name:x:+/+/*/1
                     get-value:x:@.dp/#/*/name
                  set-value:x:+/*/1
                     get-value:x:@.dp/#/*/type
                  add:x:@apply/*/.arguments
                     .
                        ..
                        .

         // First adding the [add] into [where] parts, which are the primary keys.
         .x:@.arguments/*/[0,
         set-value:x:@.x
            strings.concat
               get-value:x:@.x
               get-count:x:@.arguments/*/args/*/primary/*
               .:]
         set-x:x:+/*/*/0
            convert:x:@.x
               type:x
         insert-before:x:@apply/**/table/././1
            .

               // Parametrising our update invocation.
               ..:Parametrising our invocation.
               add:x:./*/data.update/*/where/*/and
                  get-nodes

         /*
          * Then adding the [add] into [values] parts, which are the values to update.
          * 
          * Notice, we assume there are less than 1.000 values to update, which should be
          * enough for any sane database table.
          */
         .x:@.arguments/*/[
         set-value:x:@.x
            strings.concat
               get-value:x:@.x
               get-count:x:@.arguments/*/args/*/primary/*
               .:,1000]
         set-x:x:+/*/*/*
            convert:x:@.x
               type:x
         insert-before:x:@apply/**/table/././2
            .
               add:x:./*/data.update/*/values
                  get-nodes

         // Making sure we apply "locked" columns.
         for-each:x:@.arguments/*/args/*/columns/*/*/locked/.
            set-name:x:+/*/1
               get-value:x:@.dp/#/*/locked
            insert-before:x:@apply/*/data.connect/-
               .
                  ..:Making sure we retrieve lock value for column.
                  .
            .x
            set-value:x:@.x
               strings.concat
                  .:@
                  get-value:x:@.dp/#/*/locked
            convert:x:@.x
               type:x
            set-x:x:+/+/*/1
               get-value:x:@convert
            set-name:x:+/*/1
               strings.concat
                  get-value:x:@.dp/#/*/name
                  .:.eq
            add:x:@apply/*/data.connect/*/data.update/*/where/*/and
               .
                  ..:Table is locked on the following field.
                  .

   // Notice, we only apply the CQRS pattern to post, put and delete endpoints.
   switch:x:@.arguments/*/verb
      case:put
      case:post
      case:delete

         // Checking if caller wants to publish socket messages in his endpoint.
         if
            and
               exists:x:@.arguments/*/cqrs
               get-value:x:@.arguments/*/cqrs
            .lambda

               /*
                * Applying [sockets.signal] just before returning from endpoint.
                * 
                * First creating signal name.
                */
               .signal
               set-value:x:@.signal
                  strings.concat
                     get-value:x:@.arguments/*/moduleName
                     .:.
                     get-value:x:@.arguments/*/moduleUrl
                     .:.
                     get-value:x:@.arguments/*/verb

               // Adding [sockets.signal] invocation to lambda.
               unwrap:x:+/*/*/sockets.signal
               insert-before:x:@apply/*/data.connect/*/unwrap/-
                  .
                     ..:Publishing socket message.
                     add:x:./*/sockets.signal/*/args
                        get-nodes:x:@.arguments/*
                     sockets.signal:x:@.signal
                        args

               // Applying authorisation requirements for signal invocation.
               switch:x:@.arguments/*/cqrsAuthorisation

                  case:inherited

                     // SignalR socket invocation should use same authorisation as endpoint.
                     insert-before:x:@apply/*/data.connect/*/sockets.signal
                        .
                           add:x:./*/sockets.signal
                              get-nodes:x:@auth.ticket.verify
                           set-name:x:./*/sockets.signal/*/auth.ticket.verify
                              .:roles

                  case:roles

                     // SignalR socket invocation should use explicit roles when published.
                     unwrap:x:+/*/*/roles
                     add:x:@apply/*/data.connect/*/sockets.signal
                        .
                           roles:x:@.arguments/*/cqrsAuthorisationValues

                  case:groups

                     // SignalR socket invocation should use explicit roles when published.
                     unwrap:x:+/*/*/groups
                     add:x:@apply/*/data.connect/*/sockets.signal
                        .
                           groups:x:@.arguments/*/cqrsAuthorisationValues

                  case:users

                     // SignalR socket invocation should use explicit roles when published.
                     unwrap:x:+/*/*/users
                     add:x:@apply/*/data.connect/*/sockets.signal
                        .
                           users:x:@.arguments/*/cqrsAuthorisationValues

   /*
    * Then creating our folder if necessary.
    * 
    * We find the foldername here, by taking the entire filepath, and
    * removing its filename. Then we create the folder.
    */
   .folder:/modules/
   set-value:x:@.folder
      strings.concat
         get-value:x:@.folder
         get-value:x:@.arguments/*/moduleName
         .:/
   strings.split:x:@.filename
      .:/
   remove-nodes:x:-/0/-
   set-value:x:@.folder
      strings.concat
         get-value:x:@.folder
         strings.join:x:@strings.split/*
            .:/
         .:/
   io.folder.create:x:@.folder

   // Applying the correct description to the file.
   .database-name
   strings.split:x:@.arguments/*/database
      .:|
   strings.split:x:@strings.split/1
      .:]
   set-value:x:@.database-name
      get-value:x:@strings.split/0
   set-value:x:@apply/*/.description
      strings.replace:x:@apply/*/.description
         .:{database}
         get-value:x:@.database-name
   set-value:x:@apply/*/.description
      strings.replace:x:@apply/*/.description
         .:{table}
         get-value:x:@.arguments/*/table

   // Applying comment's tail.
   set-value:x:@apply/*/.description
      get-value:x:@apply/*/.description

   // Applying the correct comment to the file.
   set-value:x:@apply/0
      get-value:x:@apply/*/.description

   /*
    * Transforming lambda to Hyperlambda, and saving it to the correct file, making sure
    * we give the filename the correct HTTP verb, extension, etc.
    */
   lambda2hyper:x:@apply/*
      comments:bool:true
   unwrap:x:+
   .path:x:@.folder
   strings.split:x:@.filename
      .:/
   set-value:x:@.path
      strings.concat
         get-value:x:@.path
         get-value:x:@strings.split/0/-
         .:.
         get-value:x:@.arguments/*/verb
         .:.hl

   // Substituting illegal characters in our filename, such as spaces, etc.
   strings.replace:x:@.path
      .:" "
      .:_

   // Throwing an exception if the file exists from before, unless [.argument][overwrite] is true.
   if
      and
         or
            not
               exists:x:@.arguments/*/overwrite
            not
               get-value:x:@.arguments/*/overwrite
         io.file.exists:x:@strings.replace
      .lambda
         throw:Module already exists
            status:int:401
            public:bool:true

   /*
    * Saving file, now transformed according to arguments, database, table, columns etc -
    * And with the correct filename.
    */
   io.file.save:x:@strings.replace
      get-value:x:@lambda2hyper

   /*
    * Calculating how many lines of code we created.
    * 
    * This is returned back to the caller after crudification is done.
    */
   get-count:x:@apply/**

   /*
    * Checking if this is an HTTP GET verb, at which point we create TWO endpoints,
    * one to retrieve actual data, and another to retrieve the count of records in table.
    * 
    * This is done by taking our existing "get items" lambda structure, and modifying it
    * until it becomes a "get count" endpoint file instead.
    */
   if
      eq
         get-value:x:@.arguments/*/verb
         .:get
      .lambda

         /*
          * First removing [columns], adding [count(*)
          * as count, and then transforming lambda
          * to Hyperlambda, and saving it to the correct file - Which is the same filename as the
          * plain get, except appending "-count" to it.
          */
         remove-nodes:x:@apply/**/columns/*
         remove-nodes:x:@apply/**/table/././*/remove-nodes
         remove-nodes:x:@apply/**/return-nodes
         remove-nodes:x:@apply/**/table/././*/add/-
         remove-nodes:x:@apply/**/table/././*/add
         remove-nodes:x:@apply/*/.arguments/*/limit/-
         remove-nodes:x:@apply/*/.arguments/*/limit
         remove-nodes:x:@apply/*/.arguments/*/offset/-
         remove-nodes:x:@apply/*/.arguments/*/offset
         remove-nodes:x:@apply/*/.arguments/*/order/-
         remove-nodes:x:@apply/*/.arguments/*/order
         remove-nodes:x:@apply/*/.arguments/*/direction/-
         remove-nodes:x:@apply/*/.arguments/*/direction
         set-value:x:@apply/*/.type
            .:crud-count
         set-value:x:@apply/*/.description
            strings.replace:Counts items from your {table} table in your {database} database
               .:{database}
               get-value:x:@.database-name
         set-value:x:@apply/*/.description
            strings.replace:x:@apply/*/.description
               .:{table}
               get-value:x:@.arguments/*/table
         set-value:x:@apply/0
            get-value:x:@apply/*/.description
         add:x:@apply/**/columns
            .
               count(*)
                  as:count
         add:x:@apply/**/table/.
            .
               limit:long:1
         if
            and
               exists:x:@.arguments/*/verbose
               get-value:x:@.arguments/*/verbose
            .lambda
               insert-before:x:@apply/**/table/./-
                  .
                     ..:Adding filtering arguments.
                     add:x:+/*/where/*
                        get-nodes:x:@.arguments/*

         else
            insert-before:x:@apply/**/table/./-
               .
                  add:x:+/*/where/*
                     get-nodes:x:@.arguments/*

         insert-after:x:@apply/**/table/./+
            .
               return-nodes:x:@data.read/*/*
         lambda2hyper:x:@apply/*
            comments:bool:true
         unwrap:x:+
         .path:x:@.folder
         strings.split:x:@.filename
            .:/
         set-value:x:@.path
            strings.concat
               get-value:x:@.path
               get-value:x:@strings.split/0/-
               .:-count
               .:.
               get-value:x:@.arguments/*/verb
               .:.hl

         // Figuring out filename for HTTP endpoint.
         strings.replace:x:@.path
            .:" "
            .:_

         // Making sure file does not exist from before, unless [.argument][overwrite] is true.
         if
            and
               or
                  not
                     exists:x:@.arguments/*/overwrite
                  not
                     get-value:x:@.arguments/*/overwrite
               io.file.exists:x:@strings.replace
            .lambda
               throw:Module already exists
                  status:int:401
                  public:bool:true

         /*
          * Saving file, now applied according to template declaration,
          * and with the correct filename.
          */
         io.file.save:x:@strings.replace
            get-value:x:@lambda2hyper

         // Adding count endpoint LOC count to our above LOC value.
         set-value:x:@get-count
            math.add
               get-value:x:@get-count
               get-count:x:@apply/**

         // Buffering [apply] in case user wants to generate distinct endpoint.
         .apply
         add:x:@.apply
            get-nodes:x:@apply/*

         // Checking if caller wants to generate aggregate endpoint.
         if:x:@.arguments/*/aggregate

            // Creating aggregate endpoint.
            set-value:x:@apply/*/.type
               .:crud-aggregate
            set-value:x:@apply/*/.description
               strings.replace:Returns minimum, maximum, average or sum from your {table} table in your {database} database
                  .:{database}
                  get-value:x:@.database-name
            set-value:x:@apply/*/.description
               strings.replace:x:@apply/*/.description
                  .:{table}
                  get-value:x:@.arguments/*/table
            set-value:x:@apply/0
               get-value:x:@apply/*/.description
            insert-before:x:@apply/*/.arguments/0
               .
                  ..:Function to aggregate upon. Argument is mandatory and legal values are min, max, sum or avg
                  aggregate_function:string
                  ..:Argument is mandatory and must be in the format of TABLE_NAME.COLUMN_NAME.
                  aggregate_column:string
            set-value:x:@apply/**/count(*)/0
               .:result
            set-name:x:@apply/**/count(*)
               .:aggregate_functor
            insert-after:x:@apply/*/data.connect/*/database-type
               .
                  ..:Making sure we're using correct aggregate function.
                  set-name:x:./*/data.read/*/columns/*/aggregate_functor
                     strings.concat
                        get-value:x:@.arguments/*/aggregate_function
                        .:(
                        get-value:x:@.arguments/*/aggregate_column
                        .:)
                  ..:Removing aggregate arguments to simplify adding other arguments.
                  remove-nodes:x:@.arguments/*/[0,2]
            add:x:+/*/6
               get-nodes:x:@.temp-cols/*
            insert-after:x:@apply/*/.type
               .
                  ..:Sanity checking mandatory arguments.
                  validators.mandatory:x:@.arguments/*/aggregate_function
                  validators.mandatory:x:@.arguments/*/aggregate_column
                  ..:Sanity checking name of aggregate function.
                  validators.enum:x:@.arguments/*/aggregate_function
                     .:min
                     .:max
                     .:sum
                     .:avg
                  ..:Sanity checking agggregate column name.
                  validators.enum:x:@.arguments/*/aggregate_column

            // Storing current result to be able to create group by endpoint.
            .group
            add:x:@.group
               get-nodes:x:@apply/*

            // Transforming lambda to Hyperlambda and persisting as CRUD endpoint.
            lambda2hyper:x:@apply/*
               comments:bool:true
            unwrap:x:+
            .path:x:@.folder
            strings.split:x:@.filename
               .:/
            set-value:x:@.path
               strings.concat
                  get-value:x:@.path
                  get-value:x:@strings.split/0/-
                  .:-aggregate
                  .:.
                  get-value:x:@.arguments/*/verb
                  .:.hl

            // Figuring out filename for HTTP endpoint.
            strings.replace:x:@.path
               .:" "
               .:_

            // Making sure file does not exist from before, unless [.argument][overwrite] is true.
            if
               and
                  or
                     not
                        exists:x:@.arguments/*/overwrite
                     not
                        get-value:x:@.arguments/*/overwrite
                  io.file.exists:x:@strings.replace
               .lambda
                  throw:Module already exists
                     status:int:401
                     public:bool:true

            /*
             * Saving file, now applied according to template declaration,
             * and with the correct filename.
             */
            io.file.save:x:@strings.replace
               get-value:x:@lambda2hyper

            // Adding count endpoint LOC count to our above LOC value.
            set-value:x:@get-count
               math.add
                  get-value:x:@get-count
                  get-count:x:@apply/**

            /*
             * Creating group endpoint.
             */
            set-value:x:@.group/*/.type
               .:crud-group
            set-value:x:@.group/*/.description
               strings.replace:Returns minimum, maximum, average, sum or count from your {table} table in your {database} database grouped by a column
                  .:{database}
                  get-value:x:@.database-name
            set-value:x:@.group/*/.description
               strings.replace:x:@.group/*/.description
                  .:{table}
                  get-value:x:@.arguments/*/table
            set-value:x:@.group/0
               get-value:x:@.group/*/.description
            add:x:@.group/*/validators.enum/*/=sum/.
               .
                  .:count
            remove-nodes:x:@.group/*/data.connect/*/data.read/*/limit
            remove-nodes:x:@.group/*/data.connect/*/return-nodes
            add:x:@.group/*/data.connect
               .
                  return-nodes:x:@data.read/*
            insert-before:x:@.group/*/.arguments/0
               .
                  ..:Mandatory argument being column to group by and must be in the format of TABLE_NAME.COLUMN_NAME
                  group_column:string
                  ..:Number of records to return, defaults to 25 if not specified. Pass in -1 to return all records.
                  limit:long
                  ..:Offset into the dataset of where to start retrieving records
                  offset:long
                  ..:Fully qualified name of column to order by, must be in TABLE_NAME.COLUMN_NAME format
                  order:string
                  ..:"What direction to order, can be 'asc' or 'desc' implying ascending and descending"
                  direction:string
            set-value:x:@.group/*/.arguments/*/aggregate_function/-
               .:Function to aggregate upon. Argument is mandatory and legal values are min, max, sum, avg or count
            insert-before:x:@.group/*/validators.mandatory/[0,1]
               .
                  validators.mandatory:x:@.arguments/*/group_column
            add:x:+/*/1
               get-nodes:x:@.group/*/validators.enum/[1,1]/*
            insert-after:x:@.group/*/validators.enum/[0,1]
               .
                  ..:Sanity checking group column.
                  validators.enum:x:@.arguments/*/group_column
            add:x:@.group/*/data.connect/*/data.read
               .
                  group
                     group_column
            insert-after:x:@.group/*/data.connect/*/database-type
               .
                  ..:"Making sure we're using the correct group column"
                  set-name:x:@data.connect/*/data.read/*/group/*/group_column
                     get-value:x:@.arguments/*/group_column
                  ..:Making sure we return group column as a part of the result
                  set-name:x:+/*/*
                     get-value:x:@.arguments/*/group_column
                  insert-before:x:@data.connect/*/data.read/*/columns/0
                     .
                        group_column
                  ..:Changing name of aggregate column returned to caller.
                  set-value:x:@data.connect/*/data.read/*/columns/1/*/as
                     get-value:x:@.arguments/*/aggregate_function
                  ..:Removing group column to simplify adding other arguments
                  remove-nodes:x:@.arguments/*/group_column
                  ..:Adding paging arguments
                  add:x:@data.connect/*/data.read
                     get-nodes:x:@.arguments/*/limit
                     get-nodes:x:@.arguments/*/offset
                  remove-nodes:x:@.arguments/*/limit
                  remove-nodes:x:@.arguments/*/offset
                  ..:Parametrising our read invocation with ordering arguments if specified.
                  add:x:./*/data.read
                     get-nodes:x:@.arguments/*/order
                     get-nodes:x:@.arguments/*/direction
                  remove-nodes:x:@.arguments/*/order
                  remove-nodes:x:@.arguments/*/direction

            // Transforming lambda to Hyperlambda and persisting as CRUD endpoint.
            lambda2hyper:x:@.group/*
               comments:bool:true
            unwrap:x:+
            .path:x:@.folder
            strings.split:x:@.filename
               .:/
            set-value:x:@.path
               strings.concat
                  get-value:x:@.path
                  get-value:x:@strings.split/0/-
                  .:-group
                  .:.
                  get-value:x:@.arguments/*/verb
                  .:.hl

            // Figuring out filename for HTTP endpoint.
            strings.replace:x:@.path
               .:" "
               .:_

            // Making sure file does not exist from before, unless [.argument][overwrite] is true.
            if
               and
                  or
                     not
                        exists:x:@.arguments/*/overwrite
                     not
                        get-value:x:@.arguments/*/overwrite
                  io.file.exists:x:@strings.replace
               .lambda
                  throw:Module already exists
                     status:int:401
                     public:bool:true

            /*
             * Saving file, now applied according to template declaration,
             * and with the correct filename.
             */
            io.file.save:x:@strings.replace
               get-value:x:@lambda2hyper

            // Adding count endpoint LOC count to our above LOC value.
            set-value:x:@get-count
               math.add
                  get-value:x:@get-count
                  get-count:x:@.group/**

         // Checking if caller wants to generate distinct endpoint.
         if:x:@.arguments/*/distinct

            // Creating distinct endpoint.
            set-value:x:@.apply/*/.type
               .:crud-distinct
            set-value:x:@.apply/*/.description
               strings.replace:Returns unique and distinct values from your {table} table in your {database} database
                  .:{database}
                  get-value:x:@.database-name
            set-value:x:@.apply/*/.description
               strings.replace:x:@.apply/*/.description
                  .:{table}
                  get-value:x:@.arguments/*/table
            set-value:x:@.apply/0
               get-value:x:@.apply/*/.description
            insert-before:x:@.apply/*/.arguments/0
               .
                  ..:Name of column to return unique and distinct values for.
                  distinct_column:string
                  ..:Number of records to return, defaults to 25 if not specified. Pass in -1 to return all records.
                  limit:long
                  ..:Offset into the dataset of where to start retrieving records
                  offset:long
                  ..:Fully qualified name of column to order by, must be in TABLE_NAME.COLUMN_NAME format
                  order:string
                  ..:"What direction to order, can be 'asc' or 'desc' implying ascending and descending"
                  direction:string
            set-value:x:@.apply/**/count(*)/0
               .:.
            set-name:x:@.apply/**/count(*)
               .:distinct_functor
            insert-after:x:@.apply/*/data.connect/*/database-type
               .
                  ..:Making sure we're using correct function.
                  set-name:x:./*/data.read/*/columns/*/distinct_functor
                     strings.concat
                        .:distinct(
                        get-value:x:@.arguments/*/distinct_column
                        .:)
                  ..:Removing distinct argument to simplify adding other arguments.
                  remove-nodes:x:@.arguments/*/distinct_column
                  ..:Adding [limit] and [offset] arguments
                  add:x:./*/data.read
                     get-nodes:x:@.arguments/*/limit
                     get-nodes:x:@.arguments/*/offset
                     get-nodes:x:@.arguments/*/order
                     get-nodes:x:@.arguments/*/direction
                  remove-nodes:x:@.arguments/*/order
                  remove-nodes:x:@.arguments/*/direction
                  remove-nodes:x:@.arguments/*/limit
                  remove-nodes:x:@.arguments/*/offset
            add:x:+/*/3
               get-nodes:x:@.temp-cols/*
            insert-after:x:@.apply/*/.type
               .
                  ..:Sanity checking that distinct column was passed in.
                  validators.mandatory:x:@.arguments/*/distinct_column
                  ..:"Sanity checking distinct column's name."
                  validators.enum:x:@.arguments/*/distinct_column
            strings.join:x:@.temp-cols/*
               .:", "
            set-value:x:@.apply/*/.arguments/*/distinct_column/-
               strings.concat
                  get-value:x:@.apply/*/.arguments/*/distinct_column/-
                  .:" Argument is mandatory and must be in the format of TABLE_NAME.COLUMN_NAME"
            remove-nodes:x:@.apply/*/data.connect/*/data.read/*/limit
            lambda2hyper:x:@.apply/*
               comments:bool:true
            unwrap:x:+
            .path:x:@.folder
            strings.split:x:@.filename
               .:/
            set-value:x:@.path
               strings.concat
                  get-value:x:@.path
                  get-value:x:@strings.split/0/-
                  .:-distinct
                  .:.
                  get-value:x:@.arguments/*/verb
                  .:.hl

            // Figuring out filename for HTTP endpoint.
            strings.replace:x:@.path
               .:" "
               .:_

            // Making sure file does not exist from before, unless [.argument][overwrite] is true.
            if
               and
                  or
                     not
                        exists:x:@.arguments/*/overwrite
                     not
                        get-value:x:@.arguments/*/overwrite
                  io.file.exists:x:@strings.replace
               .lambda
                  throw:Module already exists
                     status:int:401
                     public:bool:true

            /*
             * Saving file, now applied according to template declaration,
             * and with the correct filename.
             */
            io.file.save:x:@strings.replace
               get-value:x:@lambda2hyper

            // Adding count endpoint LOC count to our above LOC value.
            set-value:x:@get-count
               math.add
                  get-value:x:@get-count
                  get-count:x:@.apply/**

            // Creating distinct count endpoint.
            set-value:x:@.apply/*/.type
               .:crud-count-distinct
            set-value:x:@.apply/*/.description
               strings.replace:Count unique and distinct items from your {table} table in your {database} database
                  .:{database}
                  get-value:x:@.database-name
            set-value:x:@.apply/*/.description
               strings.replace:x:@.apply/*/.description
                  .:{table}
                  get-value:x:@.arguments/*/table
            set-value:x:@.apply/0
               get-value:x:@.apply/*/.description
            set-value:x:@.apply/*/.arguments/*/distinct_column/-
               .:" Argument is mandatory and must be in the format of TABLE_NAME.COLUMN_NAME"
            remove-nodes:x:@.apply/*/.arguments/*/limit/-
            remove-nodes:x:@.apply/*/.arguments/*/limit
            remove-nodes:x:@.apply/*/.arguments/*/offset/-
            remove-nodes:x:@.apply/*/.arguments/*/offset
            remove-nodes:x:@.apply/*/.arguments/*/order/-
            remove-nodes:x:@.apply/*/.arguments/*/order
            remove-nodes:x:@.apply/*/.arguments/*/direction/-
            remove-nodes:x:@.apply/*/.arguments/*/direction
            remove-nodes:x:@.apply/*/data.connect/*/database-type/+/+/*
            add:x:@.apply/*/data.connect/*/database-type/+/+
               .
                  strings.concat
                     .:"count(distinct "
                     get-value:x:@.arguments/*/distinct_column
                     .:)
            remove-nodes:x:@.apply/*/data.connect/*/remove-nodes/[0,1]/+/+/+/+/+/+
            remove-nodes:x:@.apply/*/data.connect/*/remove-nodes/[0,1]/+/+/+/+/+
            remove-nodes:x:@.apply/*/data.connect/*/remove-nodes/[0,1]/+/+/+/+
            remove-nodes:x:@.apply/*/data.connect/*/remove-nodes/[0,1]/+/+/+
            remove-nodes:x:@.apply/*/data.connect/*/remove-nodes/[0,1]/+/+
            remove-nodes:x:@.apply/*/data.connect/*/remove-nodes/[0,1]/+
            add:x:+/*/3
               get-nodes:x:@.temp-cols/*
            set-value:x:@.apply/**/distinct_functor/0
               .:count
            lambda2hyper:x:@.apply/*
               comments:bool:true
            unwrap:x:+
            .path:x:@.folder
            strings.split:x:@.filename
               .:/
            set-value:x:@.path
               strings.concat
                  get-value:x:@.path
                  get-value:x:@strings.split/0/-
                  .:-count-distinct
                  .:.
                  get-value:x:@.arguments/*/verb
                  .:.hl

            // Figuring out filename for HTTP endpoint.
            strings.replace:x:@.path
               .:" "
               .:_

            // Making sure file does not exist from before, unless [.argument][overwrite] is true.
            if
               and
                  or
                     not
                        exists:x:@.arguments/*/overwrite
                     not
                        get-value:x:@.arguments/*/overwrite
                  io.file.exists:x:@strings.replace
               .lambda
                  throw:Module already exists
                     status:int:401
                     public:bool:true

            /*
             * Saving file, now applied according to template declaration,
             * and with the correct filename.
             */
            io.file.save:x:@strings.replace
               get-value:x:@lambda2hyper

            // Adding count endpoint LOC count to our above LOC value.
            set-value:x:@get-count
               math.add
                  get-value:x:@get-count
                  get-count:x:@.apply/**

         // Checking if caller wants to generate search endpoint.
         if
            eq:x:@.arguments/*/search
               .:bool:true
            .lambda

               // Caller wants keyword density search endpoint.
               io.file.load:/system/crudifier/templates/search.template.get.hl
               hyper2lambda:x:-
                  comments:bool:true
               unwrap:x:+/*
               apply:x:@hyper2lambda
                  database-type:x:@.arguments/*/databaseType
                  database:x:@.arguments/*/database
                  table:x:@.arguments/*/table

               // Creating our file level comment.
               set-value:x:@apply/0
                  strings.replace:x:@apply/0
                     .:{table}
                     get-value:x:@.arguments/*/table
               set-value:x:@apply/0
                  strings.replace:x:@apply/0
                     .:{database}
                     get-value:x:@.database-name

               // Making sure we add columns to endpoint.
               .has-columns:bool:false
               for-each:x:@.arguments/*/args/*/columns/*
                  if
                     eq:x:@.dp/#/*/type
                        .:string
                     .lambda

                        set-value:x:@.has-columns
                           .:bool:true
                        unwrap:x:+/*/*
                        add:x:@apply/*/.columns
                           .
                              .:x:@.dp/#/*/name

               // Verifying we've actually got columns.
               if:x:@.has-columns

                  // Saving file.
                  lambda2hyper:x:@apply/*
                     comments:true
                  unwrap:x:+
                  .path:x:@.folder
                  strings.split:x:@.filename
                     .:/
                  set-value:x:@.path
                     strings.concat
                        get-value:x:@.path
                        get-value:x:@strings.split/0/-
                        .:-search
                        .:.
                        get-value:x:@.arguments/*/verb
                        .:.hl

                  // Figuring out filename for HTTP endpoint.
                  strings.replace:x:@.path
                     .:" "
                     .:_

                  // Making sure file does not exist from before, unless [.argument][overwrite] is true.
                  if
                     and
                        or
                           not
                              exists:x:@.arguments/*/overwrite
                           not
                              get-value:x:@.arguments/*/overwrite
                        io.file.exists:x:@strings.replace
                     .lambda
                        throw:Module already exists
                           status:int:401
                           public:bool:true

                  /*
                   * Saving file, now applied according to template declaration,
                   * and with the correct filename.
                   */
                  io.file.save:x:@strings.replace
                     get-value:x:@lambda2hyper

                  // Adding count endpoint LOC count to our above LOC value.
                  set-value:x:@get-count
                     math.add
                        get-value:x:@get-count
                        get-count:x:@.apply/**

   // Making sure we evict the cache entry for endpoints.
   cache.set:endpoints

   // Returning success to caller.
   unwrap:x:+/*
   return
      result:success
      loc:x:@get-count

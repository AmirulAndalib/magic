
/*
 * Scrapes the spcified [url] and returns the result as Markdown to caller.
 */
slots.create:magic.http.scrape-url

   // Sanity checking invocation.
   validators.mandatory:x:@.arguments/*/url
   validators.url:x:@.arguments/*/url

   // Retrieving URL's content.
   http.get:x:@.arguments/*/url
      headers
         User-Agent:AINIRO-MachineLearning-Spider
         Accept:text/html
         Accept-Encoding:identity

   // Sanity checking above invocation.
   if
      not
         and
            mte:x:@http.get
               .:int:200
            lt:x:@http.get
               .:int:300
      .lambda

         // Oops, logging error.
         lambda2hyper:x:@http.get
         log.error:Something went wrong while trying to crawl URL for Machine Learning data
            url:x:@.arguments/*/url
            error:x:@lambda2hyper
         throw:Something went wrong while trying to crawl URL
            public:bool:true
            status:x:@http.get
            message:x:@.arguments/*/message

   // Making sure URL returned HTML.
   if
      or
         not-exists:x:@http.get/*/headers/*/Content-Type
         not
            strings.starts-with:x:@http.get/*/headers/*/Content-Type
               .:text/html
      .lambda

         // Oops, doing some basic logging.
         lambda2hyper:x:@http.get
         log.error:URL did not return HTML content when crawling for Machine Learning snippets
            content:x:@lambda2hyper
            url:x:@.arguments/*/url
         return:bool:true

   // Converting HTML to lambda.
   html2lambda:x:@http.get/*/content

   // Buffer for snippets we found at specified URL.
   .snippets

   // Primary h1 tag's content for URL.
   .page-header
      h1
      h2
      h3
      h4
      h5
      h6

   // Buffer for URLs found in document.
   .urls

   // Temp buffer for completion.
   .tmp-completion:

   // Looping through each HTML tag in document.
   for-each:x:@html2lambda/*/html/*/body/**

      // Checking if this is a tag we need to handle.
      get-name:x:@.dp/#
      switch:x:@get-name

         // Checking if this is code.
         case:pre

            // Verifying text node exists.
            if
               exists:x:@.dp/#/**/\#text
               .lambda

                  // Checking if we need to append code to existing completion or create new completion.
                  if
                     exists:x:@.snippets/0/-/*/completion
                     .lambda

                        // Appending to existing completion.
                        set-value:x:@.snippets/0/-/*/completion
                           strings.concat
                              get-value:x:@.snippets/0/-/*/completion
                              .:"\r\n\r\n```\r\n"
                              strings.trim:x:@.dp/#/**/\#text/[0,1]
                                 .:"  \r\n\t"
                              .:"\r\n```"

                  else

                     // Adding new prompt to [.snippets] collection.
                     strings.concat
                        .:"```\r\n"
                        strings.trim:x:@.dp/#/**/\#text/[0,1]
                           .:"  \r\n\t"
                        .:"\r\n```"
                     unwrap:x:+/*/*
                     add:x:@.snippets/0/-
                        .
                           completion:x:@strings.concat

         // Checking if this is an image.
         case:img

            // Verifying we actually have a [@src] attribute.
            if
               exists:x:@.dp/#/*/\@src
               .lambda

                  // Normalising URL.
                  .url
                  if
                     and
                        not
                           strings.starts-with:x:@.dp/#/*/\@src
                              .:"http://"
                        not
                           strings.starts-with:x:@.dp/#/*/\@src
                              .:"https://"
                     .lambda

                        // Local URL, prepending base URL.
                        if
                           strings.starts-with:x:@.dp/#/*/\@src
                              .:/
                           .lambda
                              set-value:x:@.url
                                 strings.concat
                                    get-value:x:@.base
                                    get-value:x:@.dp/#/*/\@src
                        else
                           set-value:x:@.url
                              strings.concat
                                 get-value:x:@.base
                                 .:/
                                 get-value:x:@.dp/#/*/\@src
                  else

                     // URL is absolute.
                     set-value:x:@.url
                        get-value:x:@.dp/#/*/\@src

                  // Checking if we need to append code to existing completion or create new completion.
                  if
                     exists:x:@.snippets/0/-/*/completion
                     .lambda

                        // Appending to existing completion.
                        set-value:x:@.snippets/0/-/*/completion
                           strings.concat
                              get-value:x:@.snippets/0/-/*/completion
                              .:"\r\n\r\n!["
                              get-first-value
                                 strings.concat
                                    .:"Image "
                                    get-value:x:@.dp/#/*/\@alt
                                 .:Image
                              .:"]("
                              get-value:x:@.url
                              .:")"

                  else

                     // Adding new completion to [.snippets] collection.
                     strings.concat
                        .:"!["
                        get-first-value
                           strings.concat
                              .:"Image "
                              get-value:x:@.dp/#/*/\@alt
                           .:Image
                        .:"]("
                        get-value:x:@.url
                        .:")"
                     unwrap:x:+/*/*
                     add:x:@.snippets/0/-
                        .
                           completion:x:@strings.concat

         // Checking if this is a hyperlink.
         case:a

            // Checking if it's a 'local' URL, implying within the same domain as we're currently scraping.
            if
               and
                  exists:x:@.dp/#/*/\@href
                  not-null:x:@.dp/#/*/\@href
                  neq:x:@.dp/#/*/\@href
                     .:#
                  neq:x:@.dp/#/*/\@href
                     .:
                  not
                     strings.starts-with:x:@.dp/#/*/\@href
                        .:"http://"
                  not
                     strings.starts-with:x:@.dp/#/*/\@href
                        .:"https://"
               .lambda

                  // Local URL.
                  strings.split:x:@.dp/#/*/\@href
                     .:#
                  strings.trim-end:x:@strings.split/0
                     .:/
                  .tmp
                  if
                     strings.starts-with:x:@strings.trim-end
                        .:/
                     .lambda
                        set-value:x:@.tmp
                           strings.concat
                              get-value:x:@.base
                              get-value:x:@strings.trim-end
                  else
                     set-value:x:@.tmp
                        strings.concat
                           get-value:x:@.base
                           .:/
                           get-value:x:@strings.trim-end
                  if
                     not-exists:x:@.url/*/{@strings.concat}
                     .lambda
                        unwrap:x:+/*/*
                        add:x:@.urls
                           .
                              .:x:@.tmp

            else-if
               and
                  exists:x:@.dp/#/*/\@href
                  not-null:x:@.dp/#/*/\@href
                  neq:x:@.dp/#/*/\@href
                     .:#
                  neq:x:@.dp/#/*/\@href
                     .:
                  strings.starts-with:x:@.dp/#/*/\@href
                     get-value:x:@.arguments/*/url
               .lambda

                  // Absolute URL but still within base URL we're currently crawling.
                  strings.split:x:@.dp/#/*/\@href
                     .:#
                  strings.trim-end:x:@strings.split/0
                     .:/
                  if
                     not-exists:x:@.urls/*/{@strings.split/0}
                     .lambda
                        unwrap:x:+/*/*
                        add:x:@.urls
                           .
                              .:x:@strings.trim-end

         // Headers becomes prompts.
         case:h1
         case:h2
         case:h3
         case:h4
         case:h5
         case:h6

            // Creating a new prompt.
            .prompt:

            // Trimming and adding one SP characters between each part.
            for-each:x:@.dp/#/**/\#text
               set-value:x:@.prompt
                  strings.concat
                     get-value:x:@.prompt
                     strings.trim:x:@.dp/#
                        .:"  \r\n\t"
                     .:" "
            set-value:x:@.prompt
               strings.trim:x:@.prompt
                  .:" "

            // Semantically storing Hx elements.
            switch:x:@get-name
               case:h1
                  set-value:x:@.page-header/*/h1
                     get-value:x:@.prompt
                  set-value:x:@.page-header/*/h2
                  set-value:x:@.page-header/*/h3
                  set-value:x:@.page-header/*/h4
                  set-value:x:@.page-header/*/h5
                  set-value:x:@.page-header/*/h6
               case:h2
                  set-value:x:@.page-header/*/h2
                     get-value:x:@.prompt
                  set-value:x:@.page-header/*/h3
                  set-value:x:@.page-header/*/h4
                  set-value:x:@.page-header/*/h5
                  set-value:x:@.page-header/*/h6
               case:h3
                  set-value:x:@.page-header/*/h3
                     get-value:x:@.prompt
                  set-value:x:@.page-header/*/h4
                  set-value:x:@.page-header/*/h5
                  set-value:x:@.page-header/*/h6
               case:h4
                  set-value:x:@.page-header/*/h4
                     get-value:x:@.prompt
                  set-value:x:@.page-header/*/h5
                  set-value:x:@.page-header/*/h6
               case:h5
                  set-value:x:@.page-header/*/h5
                     get-value:x:@.prompt
                  set-value:x:@.page-header/*/h6
               case:h6
                  set-value:x:@.page-header/*/h6
                     get-value:x:@.prompt

            // Now creating prompt semantically by concatenating relevant Hx tags.
            set-value:x:@.prompt
            for-each:x:@.page-header/*
               if
                  and
                     not-null:x:@.dp/#
                     neq:x:@.dp/#
                        .:
                  .lambda
                     set-value:x:@.prompt
                        strings.concat
                           get-value:x:@.dp/#
                           .:" - "
                           get-value:x:@.prompt
            set-value:x:@.prompt
               strings.replace:x:@.prompt
                  .:"  "
                  .:" "
            set-value:x:@.prompt
               strings.trim-end:x:@.prompt
                  .:" -"

            // Adding new prompt to [.snippets] collection.
            unwrap:x:+/*/*/*
            add:x:@.snippets
               .
                  .
                     prompt:x:@.prompt

         // Adding extra CR/LF sequence for UL and OL.
         case:ul
         case:ol

            // Verifying that paragraph actually contained some content.
            if
               neq:x:@.completion
                  .:
               .lambda

                  // Checking if we need to append paragraph to existing completion or create new completion.
                  if
                     exists:x:@.snippets/0/-/*/completion
                     .lambda

                        // Appending to existing completion.
                        set-value:x:@.snippets/0/-/*/completion
                           strings.concat
                              get-value:x:@.snippets/0/-/*/completion
                              .:"\r\n"

                  else

                     // Adding new prompt to [.snippets] collection.
                     unwrap:x:+/*/*
                     add:x:@.snippets/0/-
                        .
                           completion:"\r\n"

         // Paragraphs becomes completions.
         case:p
         case:li

            // Making sure we've added at least one prompt.
            if
               exists:x:@.snippets/*
               .lambda

                  // Creating a new completion.
                  .completion:

                  // Trimming and adding one SP characters between each part.
                  for-each:x:@.dp/#/**/\#text
                     if
                        and
                           neq:x:@.dp/#
                              .
                           neq:x:@.dp/#
                              .:
                        .lambda
                           strings.replace:x:@.dp/#
                              .:"\r"
                              .:" "
                           strings.replace:x:@strings.replace
                              .:"\n"
                              .:" "
                           strings.replace:x:@strings.replace
                              .:"\t"
                              .:" "
                           strings.replace:x:@strings.replace
                              .:"  "
                              .:" "
                           if
                              and
                                 eq
                                    get-name:x:@.dp/#/.
                                    .:a
                                 exists:x:@.dp/#/./*/\@href
                                 not-null:x:@.dp/#/./*/\@href
                              .lambda

                                 // Normalising URL.
                                 .url
                                 if
                                    strings.starts-with:x:@.dp/#/./*/\@href
                                       .:/
                                    .lambda

                                       // Prepending base URL.
                                       set-value:x:@.url
                                          strings.concat
                                             get-value:x:@.base
                                             get-value:x:@.dp/#/./*/\@href
                                 else-if
                                    and
                                       not
                                          strings.starts-with:x:@.dp/#/./*/\@href
                                             .:"http://"
                                       not
                                          strings.starts-with:x:@.dp/#/./*/\@href
                                             .:"https://"
                                    .lambda

                                       // Prepending base URL.
                                       set-value:x:@.url
                                          strings.concat
                                             get-value:x:@.base
                                             .:/
                                             get-value:x:@.dp/#/./*/\@href
                                 else

                                    // URL is absolute.
                                    set-value:x:@.url
                                       get-value:x:@.dp/#/./*/\@href

                                 // Adding URL as Markdown to completion
                                 set-value:x:@.completion
                                    strings.concat
                                       get-value:x:@.completion
                                       .:" "
                                       .:[
                                       strings.trim:x:@strings.replace
                                          .:"  \r\n\t"
                                       .:](
                                       get-value:x:@.url
                                       .:)
                                       .:" "
                           else

                              // Anything BUT a hyperlink.
                              set-value:x:@.completion
                                 strings.concat
                                    get-value:x:@.completion
                                    strings.trim:x:@strings.replace
                                       .:"  \r\n\t"
                                    .:" "

                  // Trimming completion. Notice, there's a non-breaking space in the following string (U+00A0).
                  set-value:x:@.completion
                     strings.trim:x:@.completion
                        .:"  \r\n\t"

                  // Replacing all occurrencies of double space with single space.
                  .has-double-space:bool:true
                  while:x:@.has-double-space

                     // Checking if we've got more double spaces in completion, and if not, stopping while loop.
                     if
                        strings.contains:x:@.completion
                           .:"  "
                        .lambda
                           set-value:x:@.completion
                              strings.replace:x:@.completion
                                 .:"  "
                                 .:" "
                     else
                        set-value:x:@.has-double-space
                           .:bool:false

                  // Cleaning up punctuation.
                  set-value:x:@.completion
                     strings.replace:x:@.completion
                        .:" ."
                        .:"."
                  set-value:x:@.completion
                     strings.replace:x:@.completion
                        .:" ,"
                        .:","

                  // Checking if this is a list of some sort, at which point we turn it into an unordered list.
                  switch:x:@get-name
                     case:li
                        set-value:x:@.completion
                           strings.concat
                              .:"\r\n"
                              .:"- "
                              get-value:x:@.completion
                     case:p
                        set-value:x:@.completion
                           strings.concat
                              .:"\r\n\r\n"
                              get-value:x:@.completion

                  // Verifying that paragraph actually contained some content.
                  if
                     neq:x:@.completion
                        .:
                     .lambda

                        // Checking if we need to append paragraph to existing completion or create new completion.
                        if
                           exists:x:@.snippets/0/-/*/completion
                           .lambda

                              // Appending to existing completion.
                              set-value:x:@.snippets/0/-/*/completion
                                 strings.concat
                                    get-value:x:@.snippets/0/-/*/completion
                                    get-value:x:@.completion

                        else

                           // Adding new prompt to [.snippets] collection.
                           unwrap:x:+/*/*
                           add:x:@.snippets/0/-
                              .
                                 completion:x:@.completion

   // Returning results to caller
   return-nodes:x:@.snippets/*
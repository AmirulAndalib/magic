
/*
 * Returns Markdown training snippet from specified [html].
 *
 * Takes the following arguments:
 *
 * - [html]     - Mandatory. Being the actual HTML we're traversing for training data.
 * - [url]      - Optional.  Being the URL from where the document was fetched
 * - [semantic] - Optional.  If true, will try to start scraping from semantic tags, such as article and main.
 */
slots.create:magic.ai.html.extract

   // Sanity checking invocation.
   validators.mandatory:x:@.arguments/*/html
   validators.mandatory:x:@.arguments/*/url
   validators.url:x:@.arguments/*/url
   validators.default:x:@.arguments
      semantic:bool:false

   // Used to return meta information to caller.
   .meta
      main:int:0

   // Buffer used for snippet to return.
   .snippets

   // Buffer for title.
   .title

   // Buffer for description.
   .description

   // Used to store a reference to above HTML transformed to Markdown.
   .markdown

   // Buffer used for URLs from HTML document.
   .urls

   // Checking if caller wants to convert HTML semantically or not.
   if:x:@.arguments/*/semantic

      // Converting HTML to lambda such that we can semantically inspect HTML for semantic tags.
      html2lambda:x:@.arguments/*/html

      // Trying to retrieve HTML from main or article tag.
      if
         exists:x:@html2lambda/**/article/[0,1]
         .lambda

            // HTML contains "article" HTML element.
            lambda2html:x:@html2lambda/**/article/[0,1]
            html2markdown:x:@lambda2html
               url:x:@.arguments/*/url
            set-value:x:@.markdown
               get-value:x:@html2markdown

      else-if
         exists:x:@html2lambda/**/main/[0,1]
         .lambda

            // HTML contains "main" HTML element.
            lambda2html:x:@html2lambda/**/main/[0,1]
            html2markdown:x:@lambda2html
               url:x:@.arguments/*/url
            set-value:x:@.markdown
               get-value:x:@html2markdown

   // Checking if we've got some Markdown, and if not, resorting to using entire HTML document.
   if
      null:x:@.markdown
      .lambda

         // Using raw HTML.
         html2markdown:x:@.arguments/*/html
            url:x:@.arguments/*/url
         set-value:x:@.markdown
            get-value:x:@html2markdown

   /*
    * Finding URLs from document.
    *
    * Notice, for simplicity reasons we do this by round tripping HTML
    * through markdown, converting it to HTML, conerting HTML to lambda,
    * and iterate through each anchor HTML element in lambda.
    * This is not optimal, and could be optimised, but it keeps the code
    * DRY at least ...
    */
   html2markdown:x:@.arguments/*/html
   markdown2html:x:@html2markdown
   html2lambda:x:@markdown2html
   for-each:x:@html2lambda/**/a/*/\@href

      /*
       * Notice, the URLs we return are for the scraper to crawl and scrape,
       * so we don't return mailto or tel URLs here, and we only return URLs
       * from the same domain.
       */
      if
         and
            not
               strings.starts-with:x:@.dp/#
                  .:"mailto:"
            not
               strings.starts-with:x:@.dp/#
                  .:"tel:"
         .lambda

            // Valid URL, now checking if it's the same domain.
            .local
            strings.split:x:@.arguments/*/url
               .:"/"
            set-value:x:@.local
               get-value:x:@strings.split/1
            .current
            strings.split:x:@.dp/#
               .:"/"
            set-value:x:@.current
               get-value:x:@strings.split/1
            if
               eq:x:@.local
                  get-value:x:@.current
               .lambda

                  // Local URL, now making sure it's not the same URL.
                  strings.trim-end:x:@.dp/#
                     .:/
                  strings.trim-end:x:@.arguments/*/url
                     .:/
                  if
                     neq:x:@strings.trim-end
                        get-value:x:@strings.trim-end/@strings.trim-end
                     .lambda
                     
                        // Not the same URLas the one we'recurrently scraping.
                        unwrap:x:+/*/*
                        add:x:@.urls
                           .
                              .:x:@.dp/#

   // Setting title and description from document.
   set-value:x:@.title
      get-value:x:@html2lambda/**/meta/**/title/*/\#text
   set-value:x:@.description
      get-value:x:@html2lambda/**/meta/**/meta/*/\@name/=description/./*/\@content

   // Creating our prompt.
   .prompt
   set-value:x:@.prompt
      get-first-value
         get-value:x:@.title
         get-value:x:@html2lambda/**/h1/[0,1]/*/\#text
         get-value:x:@html2lambda/**/h2/[0,1]/*/\#text
         get-value:x:@html2lambda/**/h3/[0,1]/*/\#text
         get-value:x:@html2lambda/**/h4/[0,1]/*/\#text
         get-value:x:@html2lambda/**/h5/[0,1]/*/\#text
         get-value:x:@html2lambda/**/h6/[0,1]/*/\#text
         get-value:x:@.description

   // Breaking page into sections.
   .remaining
   .tmp-prompt
   set-value:x:@.tmp-prompt
      get-value:x:@.prompt
   for-each:x:@html2lambda/*

      get-name:x:@.dp/#
      switch:x:@get-name

         case:h1
         case:h2
         case:h3
         case:h4
         case:h5
         case:h6
            set-value:x:@.tmp-prompt
               get-value:x:@.dp/#/*/\#text

         case:ul
         case:ol

            /*
             * To avoid repeating navbars "everywhere" we remove these from Markdown and returns
             * these as individual training snippets. This will ensure navbars are only imported
             * once, as a separated training snippet.
             */
            lambda2html:x:@.dp/#
            html2markdown:x:@lambda2html
            unwrap:x:+/*/*/*
            add:x:@.snippets
               .
                  .
                     prompt:x:@.tmp-prompt
                     completion:x:@html2markdown

         default
            add:x:@.remaining
               get-nodes:x:@.dp/#

   lambda2html:x:@.remaining/*
   set-value:x:@.markdown
      html2markdown:x:@lambda2html

   .completion
   set-value:x:@.completion
      get-value:x:@.markdown
   unwrap:x:+/*/*/*
   add:x:@.snippets
      .
         .
            prompt:x:@.prompt
            completion:x:@.completion

   // Returning snippets to caller if we could find anything.
   if
      exists:x:@.snippets/*
      .lambda

         // Returning snippets and meta information to caller.
         add:x:./*/return/*/snippets
            get-nodes:x:@.snippets/*
         add:x:./*/return/*/meta
            get-nodes:x:@.meta/*
         add:x:./*/return/*/urls
            get-nodes:x:@.urls/*
         return
            urls
            snippets
            meta
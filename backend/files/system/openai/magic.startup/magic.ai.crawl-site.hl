
/*
 * Crawls the specified website generating training data for machine learning in the process.
 */
slots.create:magic.ai.crawl-site

   // Creating a thread and invoking file doing the heavy lifting.
   insert-before:x:./*/fork/0
      get-nodes:x:@.arguments
   fork

      // Making sure exceptions does not leave thread.
      try

         /*
          * Loading robots.txt from specified [url].
          */
         unwrap:x:+/*
         signal:magic.ai.load-robots
            url:x:@.arguments/*/url

         // Checking if site contains a robots.txt file.
         if
            eq:x:@signal/*/found
               .:bool:true
            .lambda

               // Site contains a robots.txt file, signaling frontend of that fact.
               sockets.signal:magic.backend.chatbot
                  roles:root
                  args
                     message:Site has robots.txt
                     type:info
               sleep:100
               strings.concat
                  .:"Found "
                  get-count:x:@signal/*/sitemap/*
                  .:" sitemaps in robots.txt file"

               // Signaling frontend how many sitemaps we found in robots.txt file.
               unwrap:x:+/**
               sockets.signal:magic.backend.chatbot
                  roles:root
                  args
                     message:x:@strings.concat
                     type:info
               sleep:100

         else

            // Site does not contain a robots.txt file, signaling that fact to frontend.
            sockets.signal:magic.backend.chatbot
               roles:root
               args
                  message:Could not find a robots.txt file for website
                  type:info
            sleep:100
            strings.concat
               .:"We will try to retrieve sitemap from "
               get-value:x:@signal/*/sitemap/0
            unwrap:x:+/**
            sockets.signal:magic.backend.chatbot
               roles:root
               args
                  message:x:@strings.concat
                  type:info
            sleep:100

         /*
          * Trying to load URLs from sitemap returned from above invocation.
          */
         add:x:./*/signal/[1,2]
            get-nodes:x:@signal/*/sitemap
            get-nodes:x:@signal/*/allow
            get-nodes:x:@signal/*/disallow
         unwrap:x:+/*
         signal:magic.ai.load-sitemap
            max:x:@.arguments/*/max

         // Signaling frontend how many URLs we found, and how many there are in total.
         strings.concat
            .:"We found "
            get-value:x:@signal/*/total
            .:" URLs in sitemap"
         unwrap:x:+/**
         sockets.signal:magic.backend.chatbot
            roles:root
            args
               message:x:@strings.concat
               type:info
         sleep:100

         // Checking if site contains more URLs than we're scraping.
         get-count:x:@signal/*/urls/*
         if
            mt
               get-value:x:@signal/*/total
               get-value:x:@get-count
            .lambda

               // Warning user!
               strings.concat
                  .:"Warning, site contains more than "
                  get-value:x:@get-count
                  .:" URLs and will only be partially scraped"
               unwrap:x:+/**
               sockets.signal:magic.backend.chatbot
                  roles:root
                  args
                     message:x:@strings.concat
                     type:warning
               sleep:100

         // Iterating through each URL returned from above invocation.
         for-each:x:@signal/*/urls/*

            // Scraping currently iterated URL.
            unwrap:x:+/*
            signal:magic.ai.url.scrape
               url:x:@.dp/#
               type:x:@.arguments/*/type
               images:bool:true
               code:bool:true
               lists:bool:true
               main:bool:true
               empty-completion:bool:true
               threshold:x:@.arguments/*/threshold

            // Signaling frontend that we're waiting for n milliseconds.
            strings.concat
               .:"Waiting for "
               get-value:x:@.arguments/*/delay
               .:" milliseconds to avoid exhausting web server"
            unwrap:x:+/**
            sockets.signal:magic.backend.chatbot
               roles:root
               args
                  message:x:@strings.concat
                  type:info
            sleep:100

            // Sleeping for [delay] milliseconds to avoid exhausting web server.
            sleep:x:@.arguments/*/delay

         /*
          * Crawling is done.
          * Making sure we notify client that we're done and do some logging.
          */
         sockets.signal:magic.backend.message
            roles:root
            args
               message:Done creating OpenAI training data from URL
               type:success
         sleep:100

         // Basic logging.
         log.info:OpenAI training data successfully created
            url:x:@.arguments/*/url
            type:x:@.arguments/*/type

         // Checking if caller wants us to execute some lambda object once we're done.
         if
            exists:x:@.arguments/*/.onafter
            .lambda
               eval:x:@.arguments/*/.onafter

      .catch

         // Oops ...!!
         log.error:x:@.arguments/*/message
            url:x:@.arguments/*/url

         // Signaling frontend.
         strings.concat
            .:"Error - "
            get-value:x:@.arguments/*/message
         unwrap:x:+/*/args/*
         sockets.signal:magic.backend.chatbot
            roles:root
            args
               message:x:@strings.concat
               type:error
         sleep:100

         // Checking if caller supplied [.onerror] handler.
         if
            exists:x:@.arguments/@.arguments/*/.onerror
            .lambda
               add:x:+/+
                  get-nodes:x:@.arguments/*
               add:x:+
                  get-nodes:x:@.arguments/@.arguments/*
               invoke:x:@.arguments/@.arguments/*/.onerror

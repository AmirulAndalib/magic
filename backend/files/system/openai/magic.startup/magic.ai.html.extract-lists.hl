
/*
 * Extracts all lists and returns as Markdown training snippets to caller from
 * specified [html] argument expected to contain the HTML to traverse.
 *
 * Optionally provide a [base] and [scheme] argument which will be used
 * for relative hyperlinks. Notice, if hyperlink is relative, and you do not
 * provide [base] and [scheme], this slot will throw an exception since
 * it will not be able to correctly determine the URL of the hyperlink.
 *
 * Also provide a [base-prompt] argument which will be
 * used as the list's prompt.
 */
slots.create:magic.ai.html.extract-lists

   // Sanity checking invocation.
   validators.mandatory:x:@.arguments/*/html

   // Temporary buffer for each ul and ol element found in HTML.
   .buffer

   // Iterating through each [ul] element found in our HTML.
   for-each:x:@.arguments/*/html/#/**/ul

      // Adding currently iterated li items to above [.buffer].
      set-name:x:+/+/*/*
         .:ul
      add:x:+/*/*
         get-nodes:x:@.dp/#/*/li
      add:x:@.buffer
         .
            .

   // Iterating through each [ol] element found in our HTML.
   for-each:x:@html2lambda/**/ol

      // Adding currently iterated li items to above [.buffer].
      set-name:x:+/+/*/*
         .:ol
      add:x:+/*/*
         get-nodes:x:@.dp/#/*/li
      add:x:@.buffer
         .
            .

   // Buffer for training snippets returned to caller.
   .snippets

   /*
    * Now we have all ol/ul elements from page in above [.buffer], and we
    * can traverse each list section, and create a single Markdown training snippet
    * from each separate list section, and return to caller as a training snippet.
    */
   for-each:x:@.buffer/*

      // Used to track if we've added Hyperlinks to Markdown.
      .hyperlinks:bool:false

      // Buffer for our prompt.
      .prompt

      // Our completion.
      .completion:

      // Counter for ordered list items.
      .no:int:1

      // Iterating through each child node of currently iterated ul/ol item.
      for-each:x:@.dp/#/*/li

         // Temporary completion item.
         .tmp

         // Used to track if currently iterated list item actually has relevant content.
         .has-content:bool:false

         // Checking if this is an ordered or an unordered list.
         if
            eq
               get-name:x:@.dp/#/.
               .:ol
            .lambda

               // Ordered list.
               set-value:x:@.tmp
                  strings.concat
                     get-value:x:@.no
                     .:". "

         else

            // Unordered list.
            set-value:x:@.tmp
               .:"* "

         // Iterating through each child node of currently iterated li item.
         for-each:x:@.dp/#/*

            // Checking type of node.
            get-name:x:@.dp/#
            switch:x:@get-name

               // Plain text content.
               case:#text

                  // Verifying there is something besides white spaces in item.
                  if
                     neq
                        strings.trim:x:@.dp/#
                           .:"  \r\n\t"
                        .:
                     .lambda

                        // If this is not first content, we need to append white space.
                        if
                           eq:x:@.has-content
                              .:bool:true
                           .lambda

                              // We've already found content, making sure we add white space to separate.
                              set-value:x:@.tmp
                                 strings.concat
                                    get-value:x:@.tmp
                                    .:" "

                        // Concatenating text to [.tmp].
                        set-value:x:@.tmp
                           strings.concat
                              get-value:x:@.tmp
                              strings.trim:x:@.dp/#
                                 .:"  \r\n\t"

                        // Making sure we track the fact that currently iterated list item has valuable content.
                        set-value:x:@.has-content
                           .:bool:true

               // Bold content.
               case:b
               case:strong

                  // Verifying element has text value.
                  if
                     and
                        exists:x:@.dp/#/*/\#text
                        not-null:x:@.dp/#/*/\#text
                        neq
                           strings.trim:x:@.dp/#/*/\#text
                              .:"  \r\n\t"
                           .:
                     .lambda

                        // If this is not first content, we need to append white space.
                        if
                           eq:x:@.has-content
                              .:bool:true
                           .lambda

                              // We've already found content, making sure we add white space to separate.
                              set-value:x:@.tmp
                                 strings.concat
                                    get-value:x:@.tmp
                                    .:" "

                        // Concatenating text to [.tmp].
                        set-value:x:@.tmp
                           strings.concat
                              get-value:x:@.tmp
                              .:**
                              get-value:x:@.dp/#/*/\#text
                              .:**

                        // Making sure we track the fact that currently iterated list item has valuable content.
                        set-value:x:@.has-content
                           .:bool:true

               // Italics content.
               case:i
               case:em

                  // Verifying element has text value.
                  if
                     and
                        exists:x:@.dp/#/*/\#text
                        not-null:x:@.dp/#/*/\#text
                        neq
                           strings.trim:x:@.dp/#/*/\#text
                              .:"  \r\n\t"
                           .:
                     .lambda

                        // If this is not first content, we need to append white space.
                        if
                           eq:x:@.has-content
                              .:bool:true
                           .lambda

                              // We've already found content, making sure we add white space to separate.
                              set-value:x:@.tmp
                                 strings.concat
                                    get-value:x:@.tmp
                                    .:" "

                        // Concatenating text to [.tmp].
                        set-value:x:@.tmp
                           strings.concat
                              get-value:x:@.tmp
                              .:_
                              get-value:x:@.dp/#/*/\#text
                              .:_

                        // Making sure we track the fact that currently iterated list item has valuable content.
                        set-value:x:@.has-content
                           .:bool:true

               // Span element.
               case:span

                  // Verifying element has text value.
                  if
                     and
                        exists:x:@.dp/#/*/\#text
                        not-null:x:@.dp/#/*/\#text
                        neq
                           strings.trim:x:@.dp/#/*/\#text
                              .:"  \r\n\t"
                           .:
                     .lambda

                        // If this is not first content, we need to append white space.
                        if
                           eq:x:@.has-content
                              .:bool:true
                           .lambda

                              // We've already found content, making sure we add white space to separate.
                              set-value:x:@.tmp
                                 strings.concat
                                    get-value:x:@.tmp
                                    .:" "

                        // Concatenating text to [.tmp].
                        set-value:x:@.tmp
                           strings.concat
                              get-value:x:@.tmp
                              get-value:x:@.dp/#/*/\#text

                        // Making sure we track the fact that currently iterated list item has valuable content.
                        set-value:x:@.has-content
                           .:bool:true

               // Hyperlink.
               case:a

                  // Verifying element has text value.
                  if
                     and
                        exists:x:@.dp/#/*/\#text
                        not-null:x:@.dp/#/*/\#text
                        neq
                           strings.trim:x:@.dp/#/*/\#text
                              .:"  \r\n\t"
                           .:
                        exists:x:@.dp/#/*/\@href
                        not-null:x:@.dp/#/*/\@href
                        neq
                           strings.trim:x:@.dp/#/*/\@href
                              .:"  \r\n\t"
                           .:
                        not
                           strings.starts-with:x:@.dp/#/*/\@href
                              .:"javascript:"
                        not
                           strings.ends-with:x:@.dp/#/*/\@href
                              .:#
                     .lambda

                        // Trimming text and removing CR/LF characters from it. Notice, there's a (U+00A0) character here.
                        .anchor
                        set-value:x:@.anchor
                           strings.trim:x:@.dp/#/*/\#text
                              .:"  \r\n\t"
                        set-value:x:@.anchor
                           strings.replace:x:@.anchor
                              .:"\r"
                              .:
                        set-value:x:@.anchor
                           strings.replace:x:@.anchor
                              .:"\n"
                              .:

                        // If this is not first content, we need to append white space.
                        if
                           eq:x:@.has-content
                              .:bool:true
                           .lambda

                              // We've already found content, making sure we add white space to separate.
                              set-value:x:@.tmp
                                 strings.concat
                                    get-value:x:@.tmp
                                    .:" "

                        // Concatenating hyperlink to [.tmp], making sure we first normalize URL.
                        unwrap:x:+/*
                        signal:magic.ai.url.normalize
                           url:x:@.dp/#/*/\@href
                           base:x:@.arguments/*/base
                           scheme:x:@.arguments/*/scheme
                        set-value:x:@.tmp
                           strings.concat
                              get-value:x:@.tmp
                              .:[
                              get-value:x:@.anchor
                              .:](
                              get-value:x:@signal
                              .:)

                        // Making sure we track the fact that currently iterated list item has valuable content.
                        set-value:x:@.has-content
                           .:bool:true

                        // Storing the fact that we've seen at least one hyperlink.
                        set-value:x:@.hyperlinks
                           .:bool:true

         // Verifying we've got actual content for list item.
         if
            get-value:x:@.has-content
            .lambda

               // Currently iterated list item has data.
               set-value:x:@.completion
                  strings.concat
                     get-value:x:@.completion
                     .:"\r\n"
                     get-value:x:@.tmp

               // Now checking if it's an ordered list.
               if
                  eq
                     get-name:x:@.dp/#/.
                     .:ol
                  .lambda

                     // Ordered list.
                     math.increment:x:@.no

      // Checking if we've seen hyperlinks or not, at which point we slightly modify prompt togive clues to AI.
      if
         get-value:x:@.hyperlinks
         .lambda

            // We've seen hyperlinks.
            set-value:x:@.prompt
               strings.concat
                  .:"List with links and hyperlinks - "
                  get-value:x:@.arguments/*/base-prompt

      else

         // No hyperlinks were found.
         set-value:x:@.prompt
            strings.concat
               .:"List - "
               get-value:x:@.arguments/*/base-prompt

      /*
       * Adding prompt and completion to returned snippets, but only
       * if we've got an actual prompt.
       */
      if
         neq:x:@.completion
            .:
         .lambda

            // Trimming completion to remove redundant white space characters.
            set-value:x:@.completion
               strings.trim:x:@.completion

            // Completion is not empty.
            unwrap:x:+/*/*/*
            add:x:@.snippets
               .
                  .
                     prompt:x:@.prompt
                     completion:x:@.completion

   // Returning training snippets to caller.
   return-nodes:x:@.snippets/*

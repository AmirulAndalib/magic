
/*
 * Extracts all main HTML and returns as Markdown training snippets to caller from
 * specified [html] argument expected to contain the HTML to traverse.
 */
slots.create:magic.ai.html.extract-main

   // Sanity checking invocation.
   validators.mandatory:x:@.arguments/*/html
   validators.mandatory:x:@.arguments/*/base-prompt

   // Buffer for training snippets returned to caller.
   .snippets

   // Base prompt prepended in front of all prompts.
   .base:
   if
      and
         exists:x:@.arguments/*/base-prompt
         not-null:x:@.arguments/*/base-prompt
         neq:x:@.arguments/*/base-prompt
            .:
      .lambda

         // Caller provided a base prompt.
         set-value:x:@.base
            get-value:x:@.arguments/*/base-prompt

         /*
          * Adding default snippet being nothing but base prompt.
          *
          * This is done to make sure we can extract text that exists on
          * page before any Hx tags, in addition to being able to extract
          * text from page if page doesn't contain any Hx elements at all.
          */
         unwrap:x:+/*/*/*
         add:x:@.snippets
            .
               .
                  prompt:x:@.base

   /*
    * Notice, we apply some logic here to figure out which part of our HTML document we're
    * supposed to traverse for training snippets to avoid adding too much navbar stuff, footers,
    * etc.
    *
    * Implying, we'll look for an article or main HTML element. If we find this, we will only
    * traverse elements below this, and not the entire body. If we cannot find an article or
    * a main HTML element we resort to traversing the entire body HTML element.
    *
    * This node contains a reference to our "root" HTML element, which we're modifying according
    * to how the HTML document is structured.
    */
   .root
   set-value:x:@.root
      reference:x:@.arguments/*/html/#/*/body

   // Checking if HTML document contains an [article] or [main] tag.
   if
      and
         eq:x:@.arguments/*/semantic
            .:bool:true
         exists:x:@.arguments/*/html/#/*/body/**/main/[0,1]
      .lambda

         /*
          * Using [main] tag to avoid adding navbars, footers,
          * and other irrelevant parts of our HTML.
          */
         set-value:x:@.root
            reference:x:@.arguments/*/html/#/*/body/**/main/[0,1]

   else-if
      and
         eq:x:@.arguments/*/semantic
            .:bool:true
         exists:x:@.arguments/*/html/#/*/body/**/article/[0,1]
      .lambda

         /*
          * Using [article] tag to avoid adding navbars, footers,
          * and other irrelevant parts of our HTML.
          */
         set-value:x:@.root
            reference:x:@.arguments/*/html/#/*/body/**/article/[0,1]

   // Our HX values.
   .hx
      h1
      h2
      h3
      h4
      h5
      h6

   /*
    * Now that we've found our root element to traverse for content, we
    * can start traversing that element to create training snippets we return to caller.
    */
   for-each:x:@.root/#/**

      // Getting name of currently traversed node.
      get-name:x:@.dp/#

      // Resetting HX elements according to which element we're handling.
      switch:x:@get-name

         case:h1
            set-value:x:@.hx/*/h1
            set-value:x:@.hx/*/h2
            set-value:x:@.hx/*/h3
            set-value:x:@.hx/*/h4
            set-value:x:@.hx/*/h5
            set-value:x:@.hx/*/h6
         case:h2
            set-value:x:@.hx/*/h2
            set-value:x:@.hx/*/h3
            set-value:x:@.hx/*/h4
            set-value:x:@.hx/*/h5
            set-value:x:@.hx/*/h6
         case:h3
            set-value:x:@.hx/*/h3
            set-value:x:@.hx/*/h4
            set-value:x:@.hx/*/h5
            set-value:x:@.hx/*/h6
         case:h4
            set-value:x:@.hx/*/h4
            set-value:x:@.hx/*/h5
            set-value:x:@.hx/*/h6
         case:h5
            set-value:x:@.hx/*/h5
            set-value:x:@.hx/*/h6
         case:h6
            set-value:x:@.hx/*/h6

      // Special handling for node according to its name.
      switch:x:@get-name

         // Hx tags.
         case:h1
         case:h2
         case:h3
         case:h4
         case:h5
         case:h6

            // Creating a new snippet that we return to caller.
            .prompt:
            for-each:x:@.dp/#/**/\#text

               // Adding currently iterated text snippet to [.completion].
               set-value:x:@.prompt
                  strings.concat
                     get-value:x:@.prompt
                     .:" "
                     strings.trim:x:@.dp/#
                        .:"\r\n\t "

            // Trimming prompt.
            set-value:x:@.prompt
               strings.trim:x:@.prompt
                  .:"Â  \r\n\t"

            // Making sure tag contains anything before creating new snippet.
            if
               neq:x:@.prompt
                  .:
               .lambda

                  // Making sure we correctly store HX value.
                  set-value:x:@.hx/*/{@get-name}
                     get-value:x:@.prompt

                  // Creating our prompt from base prompt + Hx elements.
                  .tmp:
                  for-each:x:@.hx/*

                     // Verifying currently iterated HX element has text.
                     if
                        not-null:x:@.dp/#
                        .lambda

                           // Concatenating currently iterated HX element's value to above [.tmp].
                           set-value:x:@.tmp
                              strings.concat
                                 get-value:x:@.tmp
                                 .:" - "
                                 get-value:x:@.dp/#

                  // Concatenating base prompt to [.tmp].
                  set-value:x:@.tmp
                     strings.concat
                        get-value:x:@.base
                        get-value:x:@.tmp

                  // Creating a new snippet with prompt and adding to [.snippets].
                  unwrap:x:+/*/*/*
                  add:x:@.snippets
                     .
                        .
                           prompt:x:@.tmp

         // Content tags.
         case:p
         case:i
         case:em
         case:b
         case:strong
         case:span

            /*
             * Making sure we've already added at least one snippet.
             */
            if
               and
                  exists:x:@.snippets/*
                  or
                     eq:x:@get-name
                        .:p
                     and
                        not-exists:x:@.dp/#/^p
                        not-exists:x:@.dp/#/^ul
                        not-exists:x:@.dp/#/^li
               .lambda

                  // Creating a new completion.
                  .completion:

                  // Trimming and adding one SP characters between each part.
                  for-each:x:@.dp/#/**/\#text

                     // Verifying text node is not null or empty.
                     if
                        and
                           neq:x:@.dp/#
                              .
                           neq:x:@.dp/#
                              .:
                        .lambda

                           // Cleaning up text node, removing redundant CR/LF, TAB, and SP characters.
                           strings.replace:x:@.dp/#
                              .:"\r"
                              .:" "
                           strings.replace:x:@strings.replace
                              .:"\n"
                              .:" "
                           strings.replace:x:@strings.replace
                              .:"\t"
                              .:" "
                           strings.replace:x:@strings.replace
                              .:"  "
                              .:" "

                           // Checking if currently iterated #text snippet is the child of a hyperlink [a] node.
                           if
                              and
                                 eq
                                    get-name:x:@.dp/#/.
                                    .:a
                                 exists:x:@.dp/#/./*/\@href
                                 not-null:x:@.dp/#/./*/\@href
                                 neq:x:@.dp/#/./*/\@href
                                    .:
                                 not
                                    strings.ends-with:x:@.dp/#/./*/\@href
                                       .:#
                                 not
                                    strings.starts-with:x:@.dp/#/./*/\@href
                                       .:javascript
                                 not
                                    strings.starts-with:x:@.dp/#/./*/\@href
                                       .:void
                              .lambda

                                 /*
                                  * Currently iterated text snippet is a hyperlink.
                                  *
                                  * Normalizing hyperlink by invoking helper slot.
                                  */
                                 .url
                                 unwrap:x:+/*/*
                                 set-value:x:@.url
                                    signal:magic.url.normalize
                                       url:x:@.dp/#/./*/\@href
                                       base:x:@.arguments/*/base
                                       scheme:x:@.arguments/*/scheme

                                 // Checking if above invocation returned a valid URL.
                                 if
                                    not-null:x:@.url
                                    .lambda

                                       // Adding URL as Markdown to completion.
                                       set-value:x:@.completion
                                          strings.concat
                                             get-value:x:@.completion
                                             .:" "
                                             .:[
                                             strings.trim:x:@strings.replace
                                                .:"Â  \r\n\t"
                                             .:](
                                             get-value:x:@.url
                                             .:)
                                             .:" "

                                 else

                                    // Not a valid URL.
                                    set-value:x:@.completion
                                       strings.concat
                                          get-value:x:@.completion
                                          strings.trim:x:@strings.replace
                                             .:"Â  \r\n\t"
                                          .:" "

                           else

                              // Anything BUT a hyperlink.
                              set-value:x:@.completion
                                 strings.concat
                                    get-value:x:@.completion
                                    strings.trim:x:@strings.replace
                                       .:"Â  \r\n\t"
                                    .:" "

                  /*
                   * Trimming completion.
                   * Notice, there's a non-breaking space in the following string (U+00A0).
                   */
                  set-value:x:@.completion
                     strings.trim:x:@.completion
                        .:"Â  \r\n\t"

                  // Replacing all occurrencies of double space with single space.
                  .has-double-space:bool:true
                  while:x:@.has-double-space

                     // Checking if we've got more double spaces in completion, and if not, stopping while loop.
                     if
                        strings.contains:x:@.completion
                           .:"  "
                        .lambda
                           set-value:x:@.completion
                              strings.replace:x:@.completion
                                 .:"  "
                                 .:" "
                     else
                        set-value:x:@.has-double-space
                           .:bool:false

                  // Cleaning up punctuation.
                  set-value:x:@.completion
                     strings.replace:x:@.completion
                        .:" ."
                        .:"."
                  set-value:x:@.completion
                     strings.replace:x:@.completion
                        .:" ,"
                        .:","

                  // Verifying that element actually contained some content.
                  if
                     neq:x:@.completion
                        .:
                     .lambda

                        // Checking if we need to append paragraph to existing completion or create new completion.
                        if
                           exists:x:@.snippets/0/-/*/completion
                           .lambda

                              // Appending to existing completion.
                              set-value:x:@.snippets/0/-/*/completion
                                 strings.concat
                                    get-value:x:@.snippets/0/-/*/completion
                                    .:"\r\n"
                                    .:"\r\n"
                                    get-value:x:@.completion

                        else

                           // Adding new completion to [.snippets] collection.
                           unwrap:x:+/*/*
                           add:x:@.snippets/0/-
                              .
                                 completion:x:@.completion

         // Non semantic content tags.
         case:div

            /*
             * Making sure we've already added at least one snippet.
             */
            if
               exists:x:@.snippets/*
               .lambda

                  // Creating a new completion.
                  .completion:

                  /*
                   * Looping through all children tags, except DIV tags, since
                   * these will be treated specially in later iterations.
                   */
                  for-each:x:@.dp/#/*/!div/\#text

                     /*
                      * Verifying tag is not child of p, ul, ol, h1, etc.
                      *
                      * This is done because these tags are treated explicitly, and
                      * this section is only for "non-semantic" HTML where the content
                      * has been directly embedded within a DIV without any semantic p/ul/ol
                      * tags wrapping the content.
                      */
                     if
                        and
                           not-exists:x:@.dp/#/^p
                           not-exists:x:@.dp/#/^ul
                           not-exists:x:@.dp/#/^ol
                           not-exists:x:@.dp/#/^h1
                           not-exists:x:@.dp/#/^h2
                           not-exists:x:@.dp/#/^h3
                           not-exists:x:@.dp/#/^h4
                           not-exists:x:@.dp/#/^h5
                           not-exists:x:@.dp/#/^h6
                           not-exists:x:@.dp/#/^button
                           not-exists:x:@.dp/#/^style
                           not-exists:x:@.dp/#/^script
                           not-exists:x:@.dp/#/^iframe
                           not-exists:x:@.dp/#/^object
                        .lambda

                           // Verifying text node is not null or empty.
                           if
                              and
                                 neq:x:@.dp/#
                                    .
                                 neq:x:@.dp/#
                                    .:
                              .lambda

                                 // Cleaning up text node, removing redundant CR/LF, TAB, and SP characters.
                                 strings.replace:x:@.dp/#
                                    .:"\r"
                                    .:" "
                                 strings.replace:x:@strings.replace
                                    .:"\n"
                                    .:" "
                                 strings.replace:x:@strings.replace
                                    .:"\t"
                                    .:" "
                                 strings.replace:x:@strings.replace
                                    .:"  "
                                    .:" "

                                 /*
                                  * Checking if currently iterated #text snippet is the child of
                                  * a hyperlink [a] node.
                                  */
                                 if
                                    and
                                       eq
                                          get-name:x:@.dp/#/.
                                          .:a
                                       exists:x:@.dp/#/./*/\@href
                                       not-null:x:@.dp/#/./*/\@href
                                       neq:x:@.dp/#/./*/\@href
                                          .:
                                       not
                                          strings.ends-with:x:@.dp/#/./*/\@href
                                             .:#
                                       not
                                          strings.starts-with:x:@.dp/#/./*/\@href
                                             .:javascript
                                       not
                                          strings.starts-with:x:@.dp/#/./*/\@href
                                             .:void
                                    .lambda

                                       /*
                                        * Currently iterated text snippet is a hyperlink.
                                        *
                                        * Normalizing hyperlink by invoking helper slot.
                                        */
                                       .url
                                       unwrap:x:+/*/*
                                       set-value:x:@.url
                                          signal:magic.url.normalize
                                             url:x:@.dp/#/./*/\@href
                                             base:x:@.arguments/*/base
                                             scheme:x:@.arguments/*/scheme

                                       // Checking if above invocation returned a valid URL.
                                       if
                                          not-null:x:@.url
                                          .lambda

                                             // Adding URL as Markdown to completion.
                                             set-value:x:@.completion
                                                strings.concat
                                                   get-value:x:@.completion
                                                   .:" "
                                                   .:[
                                                   strings.trim:x:@strings.replace
                                                      .:"Â  \r\n\t"
                                                   .:](
                                                   get-value:x:@.url
                                                   .:)
                                                   .:" "

                                       else

                                          // Not a valid URL.
                                          set-value:x:@.completion
                                             strings.concat
                                                get-value:x:@.completion
                                                strings.trim:x:@strings.replace
                                                   .:"Â  \r\n\t"
                                                .:" "

                                 else

                                    // Anything BUT a hyperlink.
                                    set-value:x:@.completion
                                       strings.concat
                                          get-value:x:@.completion
                                          strings.trim:x:@strings.replace
                                             .:"Â  \r\n\t"
                                          .:" "

                  /*
                   * Trimming completion.
                   *
                   * Notice, there's a non-breaking space in the following string (U+00A0).
                   */
                  set-value:x:@.completion
                     strings.trim:x:@.completion
                        .:"Â  \r\n\t"

                  // Replacing all occurrencies of double space with single space.
                  .has-double-space:bool:true
                  while:x:@.has-double-space

                     // Checking if we've got more double spaces in completion, and if not, stopping while loop.
                     if
                        strings.contains:x:@.completion
                           .:"  "
                        .lambda
                           set-value:x:@.completion
                              strings.replace:x:@.completion
                                 .:"  "
                                 .:" "
                     else
                        set-value:x:@.has-double-space
                           .:bool:false

                  // Cleaning up punctuation.
                  set-value:x:@.completion
                     strings.replace:x:@.completion
                        .:" ."
                        .:"."
                  set-value:x:@.completion
                     strings.replace:x:@.completion
                        .:" ,"
                        .:","

                  // Verifying that element actually contained some content.
                  if
                     neq:x:@.completion
                        .:
                     .lambda

                        // Adding new completion to [.snippets] collection
                        unwrap:x:+/*/*
                        add:x:@.snippets
                           .
                              prompt:x:@.base
                              completion:x:@.completion

                        /*
                         * Notice, since this is not a semantic tag, we create a new
                         * snippet that's a clone of the the old prompt.
                         */
                        unwrap:x:+/*/*/*
                        add:x:@.snippets
                           .
                              .
                                 prompt:x:@.base

         // Lists.
         case:ul
         case:ol

            /*
             * Making sure we've already added at least one snippet,
             * implying we're below H1 tag somewhere.
             */
            if
               and
                  exists:x:@.snippets/*
                  eq:x:@.arguments/*/lists
                     .:bool:true
               .lambda

                  // Creating a new completion.
                  .completion:

                  // Counter for ordered list items.
                  .no:int:1

                  // Iterating through each child node of currently iterated ul/ol item.
                  for-each:x:@.dp/#/*/li

                     // Temporary completion item.
                     .tmp

                     // Used to track if currently iterated list item actually has relevant content.
                     .has-content:bool:false

                     // Checking if this is an ordered or an unordered list.
                     if
                        eq
                           get-name:x:@.dp/#/.
                           .:ol
                        .lambda

                           // Ordered list.
                           set-value:x:@.tmp
                              strings.concat
                                 get-value:x:@.no
                                 .:". "

                     else

                        // Unordered list.
                        set-value:x:@.tmp
                           .:"* "

                     // Iterating through each child node of currently iterated li item.
                     for-each:x:@.dp/#/*

                        // Checking type of node.
                        get-name:x:@.dp/#
                        switch:x:@get-name

                           // Plain text content.
                           case:#text

                              // Verifying there is something besides white spaces in item.
                              if
                                 neq
                                    strings.trim:x:@.dp/#
                                       .:"Â  \r\n\t"
                                    .:
                                 .lambda

                                    // If this is not first content, we need to append white space.
                                    if
                                       eq:x:@.has-content
                                          .:bool:true
                                       .lambda

                                          // We've already found content, making sure we add white space to separate.
                                          set-value:x:@.tmp
                                             strings.concat
                                                get-value:x:@.tmp
                                                .:" "

                                    // Concatenating text to [.tmp].
                                    set-value:x:@.tmp
                                       strings.concat
                                          get-value:x:@.tmp
                                          strings.trim:x:@.dp/#
                                             .:"Â  \r\n\t"

                                    // Making sure we track the fact that currently iterated list item has valuable content.
                                    set-value:x:@.has-content
                                       .:bool:true

                           // Handled elements
                           case:b
                           case:i
                           case:em
                           case:strong
                           case:span

                              // Verifying element has text value.
                              if
                                 and
                                    exists:x:@.dp/#/*/\#text
                                    not-null:x:@.dp/#/*/\#text
                                    neq
                                       strings.trim:x:@.dp/#/*/\#text
                                          .:"Â  \r\n\t"
                                       .:
                                 .lambda

                                    // If this is not first content, we need to append white space.
                                    if
                                       eq:x:@.has-content
                                          .:bool:true
                                       .lambda

                                          // We've already found content, making sure we add white space to separate.
                                          set-value:x:@.tmp
                                             strings.concat
                                                get-value:x:@.tmp
                                                .:" "

                                    // Concatenating text to [.tmp].
                                    set-value:x:@.tmp
                                       strings.concat
                                          get-value:x:@.tmp
                                          get-value:x:@.dp/#/*/\#text

                                    // Making sure we track the fact that currently iterated list item has valuable content.
                                    set-value:x:@.has-content
                                       .:bool:true

                           // Hyperlink.
                           case:a

                              // Verifying element has text value.
                              if
                                 and
                                    exists:x:@.dp/#/*/\#text
                                    not-null:x:@.dp/#/*/\#text
                                    neq
                                       strings.trim:x:@.dp/#/*/\#text
                                          .:"Â  \r\n\t"
                                       .:
                                    exists:x:@.dp/#/*/\@href
                                    not-null:x:@.dp/#/*/\@href
                                    neq:x:@.dp/#/*/\@href
                                       .:
                                    neq
                                       strings.trim:x:@.dp/#/*/\@href
                                          .:"Â  \r\n\t"
                                       .:
                                    not
                                       strings.starts-with:x:@.dp/#/*/\@href
                                          .:"javascript:"
                                    not
                                       strings.ends-with:x:@.dp/#/*/\@href
                                          .:#
                                 .lambda

                                    // Trimming text and removing CR/LF characters from it. Notice, there's a (U+00A0) character here.
                                    .anchor
                                    set-value:x:@.anchor
                                       strings.trim:x:@.dp/#/*/\#text
                                          .:"Â  \r\n\t"
                                    set-value:x:@.anchor
                                       strings.replace:x:@.anchor
                                          .:"\r"
                                          .:
                                    set-value:x:@.anchor
                                       strings.replace:x:@.anchor
                                          .:"\n"
                                          .:

                                    // If this is not first content, we need to append white space.
                                    if
                                       eq:x:@.has-content
                                          .:bool:true
                                       .lambda

                                          // We've already found content, making sure we add white space to separate.
                                          set-value:x:@.tmp
                                             strings.concat
                                                get-value:x:@.tmp
                                                .:" "

                                    // Concatenating hyperlink to [.tmp], making sure we first normalize URL.
                                    unwrap:x:+/*
                                    signal:magic.url.normalize
                                       url:x:@.dp/#/*/\@href
                                       base:x:@.arguments/*/base
                                       scheme:x:@.arguments/*/scheme
                                    set-value:x:@.tmp
                                       strings.concat
                                          get-value:x:@.tmp
                                          .:[
                                          get-value:x:@.anchor
                                          .:](
                                          get-value:x:@signal
                                          .:)

                                    // Making sure we track the fact that currently iterated list item has valuable content.
                                    set-value:x:@.has-content
                                       .:bool:true

                                    // Storing the fact that we've seen at least one hyperlink.
                                    set-value:x:@.hyperlinks
                                       .:bool:true

                     // Verifying we've got actual content for list item.
                     if
                        get-value:x:@.has-content
                        .lambda

                           // Currently iterated list item has data.
                           set-value:x:@.completion
                              strings.concat
                                 get-value:x:@.completion
                                 .:"\r\n"
                                 get-value:x:@.tmp

                           // Now checking if it's an ordered list.
                           if
                              eq
                                 get-name:x:@.dp/#/.
                                 .:ol
                              .lambda

                                 // Ordered list.
                                 math.increment:x:@.no

                  /*
                   * Adding prompt and completion to returned snippets, but only
                   * if we've got an actual prompt.
                   */
                  if
                     neq:x:@.completion
                        .:
                     .lambda

                        // Trimming completion to remove redundant white space characters.
                        set-value:x:@.completion
                           strings.trim:x:@.completion

                  // Verifying that element actually contained some content.
                  if
                     neq:x:@.completion
                        .:
                     .lambda

                        // Checking if we need to append list to existing completion or create new completion.
                        if
                           exists:x:@.snippets/0/-/*/completion
                           .lambda

                              // Appending to existing completion.
                              set-value:x:@.snippets/0/-/*/completion
                                 strings.concat
                                    get-value:x:@.snippets/0/-/*/completion
                                    .:"\r\n"
                                    .:"\r\n"
                                    get-value:x:@.completion

                        else

                           // Adding new completion to [.snippets] collection.
                           unwrap:x:+/*/*
                           add:x:@.snippets/0/-
                              .
                                 completion:x:@.completion

   // Returning training snippets to caller.
   return-nodes:x:@.snippets/*

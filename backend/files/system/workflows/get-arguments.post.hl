
/*
 * Returns arguments the specified action can handle,
 * in addition to candidates for expressions.
 */
.arguments
   action-file:string
   codeToCaret:string

// Verifying user is authorized to access endpoint.
auth.ticket.verify:root

/*
 * Loading action file and transforming Hyperlambda to lambda and making sure
 * we return [.arguments] collection as [input].
 *
 * This becomes our input arguments to our action.
 */
load-file:x:@.arguments/*/action-file
hyper2lambda:x:@load-file
add:x:./*/return/*/input
   get-nodes:x:@hyper2lambda/*/.arguments/*

/*
 * Transforming code specified as input to lambda such that we can
 * semantically traverse it for candidate expressions.
 */
hyper2lambda:x:@.arguments/*/codeToCaret

/*
 * Figuring out candidate expressions
 */
for-each:x:@hyper2lambda/*

   // Figuring out if we should return this as a candidate expression or not.
   .node-name
   set-value:x:@.node-name
      get-name:x:@.dp/#
   if
      or
         strings.starts-with:x:@.node-name
            .:.
         and
            eq:x:@.node-name
               .:execute
            exists:x:@.dp/#/*/name
            exists:x:@.dp/#/*/filename
      .lambda

         /*
          * Checking if we're dealing with an action invocation, at which point
          * we'll have to load the action file and figure out return values from action
          * that becomes our candidate expressions.
          */
         if
            eq:x:@.node-name
               .:execute
            .lambda

               // Action invocation, loading file such that we can inspect return values.
               load-file:x:@.dp/#/*/filename
               hyper2lambda:x:@load-file

               // Finding arguments.
               for-each:x:@hyper2lambda/**/[yield|return|return-nodes]/*

                  // Creating our candidate expression.
                  .x
                  set-value:x:@.x
                     strings.concat
                        .:--/execute/=
                        get-value:x:@.dp/@.dp/#/*/name
                        .:/*/
                        get-name:x:@.dp/#

                  // Making sure candidate expression has not already been added before we add it.
                  if
                     not-exists:x:../*/return/*/candidates/*/*/expression/={@.x}
                     .lambda

                        // Argument has not been previously added to return lambda.
                        unwrap:x:+/*/*/*
                        add:x:../*/return/*/candidates
                           .
                              .
                                 name:x:@.x
                                 expression:x:@.x

         else

            /*
             * Variable node, either [.arguments] collection, or some variable node declaration.
             *
             * Looping through children of node and creating our candidate expression.
             */
            for-each:x:@.dp/#/*

               // Creating our candidate expression.
               .x
               set-value:x:@.x
                  strings.concat
                     .:@
                     get-value:x:@.node-name
                     .:/*/
                     get-name:x:@.dp/#

               // Making sure candidate expression has not already been added before we add it.
               if
                  not-exists:x:../*/return/*/candidates/*/*/expression/={@.x}
                  .lambda

                     // Argument has not been previously added to return lambda.
                     unwrap:x:+/*/*/*
                     add:x:../*/return/*/candidates
                        .
                           .
                              name:x:@.x
                              expression:x:@.x

            // In case this is a "simple variable" we add it directly if it has a value.
            if
               not-null:x:@.dp/#
               .lambda

                  // Creating our candidate expression.
                  .x
                  set-value:x:@.x
                     strings.concat
                        .:@
                        get-value:x:@.node-name

                  // Making sure candidate expression has not already been added before we add it.
                  if
                     not-exists:x:../*/return/*/candidates/*/*/expression/={@.x}
                     .lambda

                        // Argument has not been previously added to return lambda.
                        unwrap:x:+/*/*/*
                        add:x:../*/return/*/candidates
                           .
                              .
                                 name:x:@.x
                                 expression:x:@.x

// Returning arguments to caller.
return
   input
   candidates
